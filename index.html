<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sailing Processor Model (Single File)</title>
  <style>
    :root {
      color-scheme: light dark;

      --border: rgba(127,127,127,.35);
      --border2: rgba(127,127,127,.25);
      --bgCanvas: rgba(127,127,127,.06);

      --vec: rgba(30,30,30,.92);
      --grid: rgba(127,127,127,.45);
      --hdg: rgba(127,127,127,.85);

      --pos: #1a8f3a;
      --neg: #c62828;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --border: rgba(255,255,255,.18);
        --border2: rgba(255,255,255,.12);
        --bgCanvas: rgba(255,255,255,.06);

        --vec: rgba(245,245,245,.92);
        --grid: rgba(255,255,255,.22);
        --hdg: rgba(255,255,255,.60);

        --pos: #47d16a;
        --neg: #ff5a5a;
      }
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 18px; font-weight: 650; }
    .grid { display: grid; grid-template-columns: 420px 1fr; gap: 16px; align-items: start; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; margin: 10px 0; }
    label { font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 100%; }

    input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }

    .small { font-size: 12px; opacity: .85; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 6px 8px; border-bottom: 1px solid var(--border2); }
    th { text-align: left; font-weight: 650; opacity: .9; }
    td:first-child { opacity: .85; width: 28%; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; border:1px solid var(--border); font-size: 12px; }
    .toolbar { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-top: 8px; }
    canvas { width: 100%; border-radius: 12px; border: 1px solid var(--border); background: var(--bgCanvas); display:block; }

    #cv { height: 420px; margin-top: 10px;}
    #polarCv { height: 260px; margin-top: 10px; }

    .numCtl { display: grid; grid-template-columns: 52px 1fr 52px; gap: 8px; align-items: center; }
    .pmBtn { padding: 10px 0; font-weight: 700; font-size: 18px; line-height: 1; }

    .delta { opacity: .9; }
    .delta.mono, .base.mono { font-variant-numeric: tabular-nums; }
    .delta.pos { color: var(--pos); }
    .delta.neg { color: var(--neg); }
    .delta.zero, .base.zero { opacity: .55; }

    .split2 { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }
    .miniCard { border: 0px solid var(--border2); border-radius: 12px; padding: 10px; margin-top:10px; ; }

    /* mode + tack controls */
    .modeRow { display:flex; align-items:center; gap:12px; margin: 10px 0 12px 0; }
    .modeGroup { display:flex; gap:10px; flex-wrap:wrap; }
    .modeOpt { font-size: 12px; opacity: .9; display:flex; align-items:center; gap:6px; }
    .modeSpacer { flex: 1; }
    .tackGroup[aria-disabled="true"] { opacity: .55; pointer-events: none; }
  </style>
</head>
<body>
  <!-- <h1>Sailing Processor Model</h1> -->

  <div class="grid">
    <div class="card">
      <div class="small">
        Inputs: <span class="mono">GWD, GWS, HDG, SET, DRIFT</span>.
        <br/>
        Wind dirs are <span class="mono">FROM</span>, boat/current dirs are <span class="mono">TO</span>.
        <br/>
        <span class="mono">BSP, TWA</span> comes from the loaded polar, depending on mode.
      </div>

      <hr style="border:none;border-top:1px solid var(--border2); margin: 12px 0;" />

      <!-- MODE + TACK -->
      <div class="modeRow">
        <label>Mode</label>
        <div class="modeGroup">
          <label class="modeOpt"><input type="radio" name="mode" id="modeFree" checked> free</label>
          <label class="modeOpt"><input type="radio" name="mode" id="modeVmgUp"> vUp</label>
          <label class="modeOpt"><input type="radio" name="mode" id="modeVmgDn"> vDn</label>
        </div>

        <span class="modeSpacer"></span>

        <label>Tack</label>
        <div class="modeGroup tackGroup" id="tackGroup" aria-disabled="true">
          <label class="modeOpt"><input type="radio" name="tack" id="tackPort" value="-1"> port</label>
          <label class="modeOpt"><input type="radio" name="tack" id="tackStbd" value="1" checked> stbd</label>
        </div>
      </div>

      <!-- HDG (hidden in VMG modes) -->
      <div id="hdgBlock">
        <div class="row">
          <label for="hdg">HDG</label>
          <div class="numCtl">
            <button class="pmBtn" id="hdgM" aria-label="HDG minus">−</button>
            <input id="hdgN" type="number" step="1" />
            <button class="pmBtn" id="hdgP" aria-label="HDG plus">+</button>
          </div>
        </div>
        <input id="hdg" type="range" min="0" max="359" step="1" />
      </div>

      <!-- GWD -->
      <div class="row">
        <label for="gwd">GWD</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwdM" aria-label="GWD minus">−</button>
          <input id="gwdN" type="number" step="1" />
          <button class="pmBtn" id="gwdP" aria-label="GWD plus">+</button>
        </div>
      </div>
      <input id="gwd" type="range" min="0" max="359" step="1" />

      <!-- GWS -->
      <div class="row">
        <label for="gws">GWS</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwsM" aria-label="GWS minus">−</button>
          <input id="gwsN" type="number" step="1" />
          <button class="pmBtn" id="gwsP" aria-label="GWS plus">+</button>
        </div>
      </div>
      <input id="gws" type="range" min="0" max="40" step="1" />

      <!-- SET -->
      <div class="row">
        <label for="set">SET</label>
        <div class="numCtl">
          <button class="pmBtn" id="setM" aria-label="SET minus">−</button>
          <input id="setN" type="number" step="1" />
          <button class="pmBtn" id="setP" aria-label="SET plus">+</button>
        </div>
      </div>
      <input id="set" type="range" min="0" max="359" step="1" />

      <!-- DRIFT -->
      <div class="row">
        <label for="drift">DRIFT</label>
        <div class="numCtl">
          <button class="pmBtn" id="driftM" aria-label="DRIFT minus">−</button>
          <input id="driftN" type="number" step="1" />
          <button class="pmBtn" id="driftP" aria-label="DRIFT plus">+</button>
        </div>
      </div>
      <input id="drift" type="range" min="0" max="12" step="1" />

      <div class="toolbar">
        <button id="baseline">Set baseline</button>
        <button id="reset">Reset</button>
        <span class="small" id="baselineInfo" style="margin-left:auto;"></span>
      </div>

      <div class="small" style="margin-top:10px;">
        AWA/TWA are signed in boat frame:
        <br/>• <span class="mono">+</span> stbd, <span class="mono">-</span> port
        <br/>• 0° = wind from straight ahead
      </div>
    </div>

    <div class="card">
      <table>
        <thead>
          <tr>
            <th>Key</th>
            <th class="mono">Baseline</th>
            <th class="mono">Value</th>
            <th class="mono">Delta</th>
          </tr>
        </thead>
        <tbody>

          <tr><td>COG</td><td class="mono base" id="cogB"></td><td class="mono" id="cog"></td><td class="mono delta" id="cogD"></td></tr>
          <tr><td>SOG</td><td class="mono base" id="sogB"></td><td class="mono" id="sog"></td><td class="mono delta" id="sogD"></td></tr>

          <tr><td>BSP</td><td class="mono base" id="bspB"></td><td class="mono" id="bspOut"></td><td class="mono delta" id="bspD"></td></tr>

          <tr><td>AWA</td><td class="mono base" id="awaB"></td><td class="mono" id="awa"></td><td class="mono delta" id="awaD"></td></tr>
          <tr><td>AWS</td><td class="mono base" id="awsB"></td><td class="mono" id="aws"></td><td class="mono delta" id="awsD"></td></tr>

          <tr><td>TWA</td><td class="mono base" id="twaB"></td><td class="mono" id="twa"></td><td class="mono delta" id="twaD"></td></tr>
          <tr><td>TWS</td><td class="mono base" id="twsB"></td><td class="mono" id="twsOut"></td><td class="mono delta" id="twsD"></td></tr>
          <tr><td>TWD</td><td class="mono base" id="twdB"></td><td class="mono" id="twdOut"></td><td class="mono delta" id="twdD"></td></tr>

          <tr><td>SET/DRIFT</td><td class="mono base" id="setDriftB"></td><td class="mono" id="setDrift"></td><td class="mono delta" id="setDriftD"></td></tr>
          <tr><td>GWD/GWS</td><td class="mono base" id="gwdGwsB"></td><td class="mono" id="gwdGwsEcho"></td><td class="mono delta" id="gwdGwsD"></td></tr>
        </tbody>
      </table>


      <div class="split2">
      <div>
        <canvas id="polarCv" width="980" height="360"></canvas>
        <div class="miniCard small">
          Polar view:
          <br/>• thin curves = discrete <span class="mono">TWS</span> rows
          <br/>• thick curve = interpolated at current <span class="mono">TWS</span>
          <br/>• dot = current <span class="mono">(abs(TWA), BSP)</span>
          <br>
          VMG markers:
          <br/>• <span class="mono">▲</span> upwind VMG point (<span class="mono">twaUp/bspUp</span>)
          <br/>• <span class="mono">▼</span> downwind VMG point (<span class="mono">twaDn/bspDn</span>)
        </div>
      </div>
        <canvas id="cv" width="980" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const deg2rad = d => d * Math.PI / 180;
  const rad2deg = r => r * 180 / Math.PI;
  const wrap360 = d => (d % 360 + 360) % 360;

  function angDiffDeg(a, b) {
    let d = ((a - b + 540) % 360) - 180;
    if (d === -180) d = 180;
    return d;
  }

  function vecFromBearingTo(bearingDeg, speed) {
    const a = deg2rad(bearingDeg);
    return { x: speed * Math.sin(a), y: speed * Math.cos(a) };
  }

  function bearingToFromVec(v) {
    const spd = Math.hypot(v.x, v.y);
    const brg = wrap360(rad2deg(Math.atan2(v.x, v.y)));
    return { bearing: brg, speed: spd };
  }

  function vecNEToBoat(vNE, hdgDeg) {
    const a = deg2rad(hdgDeg);
    const forward =  vNE.x * Math.sin(a) + vNE.y * Math.cos(a);
    const starbd =  vNE.x * Math.cos(a) - vNE.y * Math.sin(a);
    return { x: forward, y: starbd };
  }

  function windVecFromDirFrom(dirFromDeg, speed) {
    // returns wind velocity vector pointing TO (downwind)
    return vecFromBearingTo(wrap360(dirFromDeg + 180), speed);
  }

  function windDirFromVec(vTo) {
    // given wind velocity vector TO, return direction FROM
    const { bearing } = bearingToFromVec(vTo);
    return wrap360(bearing + 180);
  }

  function relAngleDegFromBoatVec(vBoat) {
    const ang = rad2deg(Math.atan2(vBoat.y, vBoat.x));
    return ((ang + 180) % 360) - 180;
  }

  const fmt = (x, digits=1) => Number.isFinite(x) ? x.toFixed(digits) : "—";
  const fmtDeg = (d) => Number.isFinite(d) ? `${wrap360(d).toFixed(0)}°` : "—";
  const fmtDegSigned = (d) => Number.isFinite(d) ? `${d.toFixed(0)}°` : "—";

  const el = id => document.getElementById(id);

  // ---------- POLAR (DEFAULT = your provided table) ----------
  // Each row has its own TWA points (VMG TWAs differ by TWS).
  // We add a synthetic (0°, 0 kn) to keep behavior sane near 0°.
  const POLAR_ROWS = [
    { tws: 6,  points: [
      {twa: 0,    bsp: 0},
      {twa: 44.2, bsp: 5.29},
      {twa: 52,   bsp: 5.87},
      {twa: 60,   bsp: 6.27},
      {twa: 75,   bsp: 6.62},
      {twa: 90,   bsp: 6.70},
      {twa: 110,  bsp: 6.28},
      {twa: 120,  bsp: 5.92},
      {twa: 135,  bsp: 5.27},
      {twa: 144,  bsp: 4.77},
      {twa: 180,  bsp: 2.57},
    ], vmgUp: {twa: 44.2, bsp: 5.29}, vmgDn: {twa: 144, bsp: 4.77} },

    { tws: 8,  points: [
      {twa: 0,   bsp: 0},
      {twa: 42,  bsp: 5.99},
      {twa: 52,  bsp: 6.65},
      {twa: 60,  bsp: 6.91},
      {twa: 75,  bsp: 7.19},
      {twa: 90,  bsp: 7.27},
      {twa: 110, bsp: 7.03},
      {twa: 120, bsp: 6.94},
      {twa: 135, bsp: 6.52},
      {twa: 148, bsp: 5.70},
      {twa: 180, bsp: 3.67},
    ], vmgUp: {twa: 42, bsp: 5.99}, vmgDn: {twa: 148, bsp: 5.70} },

    { tws: 10, points: [
      {twa: 0,    bsp: 0},
      {twa: 39,   bsp: 6.27},
      {twa: 52,   bsp: 6.92},
      {twa: 60,   bsp: 7.14},
      {twa: 75,   bsp: 7.52},
      {twa: 90,   bsp: 7.77},
      {twa: 110,  bsp: 7.64},
      {twa: 120,  bsp: 7.56},
      {twa: 135,  bsp: 7.20},
      {twa: 149.2,bsp: 6.59},
      {twa: 180,  bsp: 4.35},
    ], vmgUp: {twa: 39, bsp: 6.27}, vmgDn: {twa: 149.2, bsp: 6.59} },

    { tws: 12, points: [
      {twa: 0,   bsp: 0},
      {twa: 37.9,bsp: 6.37},
      {twa: 52,  bsp: 7.08},
      {twa: 60,  bsp: 7.31},
      {twa: 75,  bsp: 7.75},
      {twa: 90,  bsp: 8.16},
      {twa: 110, bsp: 8.14},
      {twa: 120, bsp: 8.27},
      {twa: 135, bsp: 7.81},
      {twa: 151, bsp: 7.07},
      {twa: 180, bsp: 4.83},
    ], vmgUp: {twa: 37.9, bsp: 6.37}, vmgDn: {twa: 151, bsp: 7.07} },

    { tws: 14, points: [
      {twa: 0,   bsp: 0},
      {twa: 38.2,bsp: 6.48},
      {twa: 52,  bsp: 7.15},
      {twa: 60,  bsp: 7.41},
      {twa: 75,  bsp: 7.92},
      {twa: 90,  bsp: 8.43},
      {twa: 110, bsp: 8.58},
      {twa: 120, bsp: 8.91},
      {twa: 135, bsp: 8.52},
      {twa: 175, bsp: 6.62},
      {twa: 180, bsp: 6.29},
    ], vmgUp: {twa: 38.2, bsp: 6.48}, vmgDn: {twa: 175, bsp: 6.62} },

    { tws: 16, points: [
      {twa: 0,   bsp: 0},
      {twa: 37.9,bsp: 6.53},
      {twa: 52,  bsp: 7.19},
      {twa: 60,  bsp: 7.46},
      {twa: 75,  bsp: 8.06},
      {twa: 90,  bsp: 8.65},
      {twa: 110, bsp: 9.17},
      {twa: 120, bsp: 9.36},
      {twa: 135, bsp: 9.39},
      {twa: 175, bsp: 7.08},
      {twa: 180, bsp: 6.73},
    ], vmgUp: {twa: 37.9, bsp: 6.53}, vmgDn: {twa: 175, bsp: 7.08} },

    { tws: 20, points: [
      {twa: 0,   bsp: 0},
      {twa: 38.6,bsp: 6.59},
      {twa: 52,  bsp: 7.31},
      {twa: 60,  bsp: 7.65},
      {twa: 75,  bsp: 8.17},
      {twa: 90,  bsp: 8.96},
      {twa: 110, bsp: 10.08},
      {twa: 120, bsp: 10.54},
      {twa: 135, bsp: 11.59},
      {twa: 141, bsp: 10.91},
      {twa: 180, bsp: 5.65},
    ], vmgUp: {twa: 38.6, bsp: 6.59}, vmgDn: {twa: 141, bsp: 10.91} },
  ].map(r => ({
    ...r,
    points: r.points.slice().sort((a,b) => a.twa - b.twa)
  }));

  const POLAR_TWS = POLAR_ROWS.map(r => r.tws);

  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  function findSpan(arr, x) {
    if (x <= arr[0]) return { i0: 0, i1: 0, t: 0 };
    if (x >= arr[arr.length - 1]) {
      const i = arr.length - 1;
      return { i0: i, i1: i, t: 0 };
    }
    for (let i = 0; i < arr.length - 1; i++) {
      if (x >= arr[i] && x <= arr[i + 1]) {
        const t = (x - arr[i]) / (arr[i + 1] - arr[i]);
        return { i0: i, i1: i + 1, t };
      }
    }
    return { i0: 0, i1: 0, t: 0 };
  }

  function evalRowAtTWA(row, twaAbs) {
    const pts = row.points;
    const twa = clamp(Math.abs(twaAbs), 0, 180);

    if (twa <= pts[0].twa) return pts[0].bsp;
    if (twa >= pts[pts.length - 1].twa) return pts[pts.length - 1].bsp;

    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i], b = pts[i + 1];
      if (twa >= a.twa && twa <= b.twa) {
        const t = (twa - a.twa) / (b.twa - a.twa);
        return lerp(a.bsp, b.bsp, t);
      }
    }
    return pts[pts.length - 1].bsp;
  }

  // interpolate across TWS by evaluating each bracketing row at requested TWA
  function polarBSP(tws, twaAbs) {
    const { i0, i1, t } = findSpan(POLAR_TWS, tws);
    const r0 = POLAR_ROWS[i0], r1 = POLAR_ROWS[i1];
    const f0 = evalRowAtTWA(r0, twaAbs);
    const f1 = evalRowAtTWA(r1, twaAbs);
    return lerp(f0, f1, t);
  }

  function polarVMGPoint(tws, which /* "up"|"dn" */) {
    const { i0, i1, t } = findSpan(POLAR_TWS, tws);
    const r0 = POLAR_ROWS[i0], r1 = POLAR_ROWS[i1];
    const p0 = which === "up" ? r0.vmgUp : r0.vmgDn;
    const p1 = which === "up" ? r1.vmgUp : r1.vmgDn;
    return {
      twa: lerp(p0.twa, p1.twa, t),
      bsp: lerp(p0.bsp, p1.bsp, t),
    };
  }

  // ---------- UI refs ----------
  const inputs = {
    hdg: el("hdg"), hdgN: el("hdgN"), hdgM: el("hdgM"), hdgP: el("hdgP"),
    gwd: el("gwd"), gwdN: el("gwdN"), gwdM: el("gwdM"), gwdP: el("gwdP"),
    gws: el("gws"), gwsN: el("gwsN"), gwsM: el("gwsM"), gwsP: el("gwsP"),
    set: el("set"), setN: el("setN"), setM: el("setM"), setP: el("setP"),
    drift: el("drift"), driftN: el("driftN"), driftM: el("driftM"), driftP: el("driftP"),
    baseline: el("baseline"),
    baselineInfo: el("baselineInfo"),
    reset: el("reset"),

    // mode/tack
    modeFree: el("modeFree"),
    modeVmgUp: el("modeVmgUp"),
    modeVmgDn: el("modeVmgDn"),
    hdgBlock: el("hdgBlock"),
    tackGroup: el("tackGroup"),
    tackPort: el("tackPort"),
    tackStbd: el("tackStbd"),
  };

  const out = {
    bspOut: el("bspOut"),
    cog: el("cog"), sog: el("sog"),
    awa: el("awa"), aws: el("aws"),
    twa: el("twa"), twsOut: el("twsOut"), twdOut: el("twdOut"),
    setDrift: el("setDrift"),
    gwdGwsEcho: el("gwdGwsEcho"),

    bspD: el("bspD"),
    cogD: el("cogD"), sogD: el("sogD"),
    awaD: el("awaD"), awsD: el("awsD"),
    twaD: el("twaD"), twsD: el("twsD"), twdD: el("twdD"),
    setDriftD: el("setDriftD"),
    gwdGwsD: el("gwdGwsD"),

    // baseline column
    bspB: el("bspB"),
    cogB: el("cogB"), sogB: el("sogB"),
    awaB: el("awaB"), awsB: el("awsB"),
    twaB: el("twaB"), twsB: el("twsB"), twdB: el("twdB"),
    setDriftB: el("setDriftB"),
    gwdGwsB: el("gwdGwsB"),
  };

  const state = {
    baseline: null,
    lastComputed: null,
    theme: null,
    mode: "free",   // "free" | "vmgUp" | "vmgDn"
    tack: +1        // +1 stbd, -1 port (only used in VMG modes)
  };

  function readTheme() {
    const cs = getComputedStyle(document.documentElement);
    state.theme = {
      vec: cs.getPropertyValue("--vec").trim() || "rgba(30,30,30,.92)",
      grid: cs.getPropertyValue("--grid").trim() || "rgba(127,127,127,.45)",
      hdg: cs.getPropertyValue("--hdg").trim() || "rgba(127,127,127,.85)",
      border: cs.getPropertyValue("--border").trim() || "rgba(127,127,127,.35)",
    };
  }

  function bindRangeAndNumber(rangeEl, numEl) {
    function clampToRange(v) {
      const min = Number(rangeEl.min), max = Number(rangeEl.max);
      if (!Number.isFinite(v)) return Number(rangeEl.value);
      return Math.min(max, Math.max(min, v));
    }
    function syncFromRange() { numEl.value = rangeEl.value; recalc(); }
    function syncFromNum() {
      const v = clampToRange(Number(numEl.value));
      rangeEl.value = String(v);
      numEl.value = String(v);
      recalc();
    }
    rangeEl.addEventListener("input", syncFromRange);
    numEl.addEventListener("input", syncFromNum);
  }

  bindRangeAndNumber(inputs.hdg, inputs.hdgN);
  bindRangeAndNumber(inputs.gwd, inputs.gwdN);
  bindRangeAndNumber(inputs.gws, inputs.gwsN);
  bindRangeAndNumber(inputs.set, inputs.setN);
  bindRangeAndNumber(inputs.drift, inputs.driftN);

  function nudge(key, dir) {
    const rangeEl = inputs[key];
    const numEl = inputs[key + "N"];
    const step = Number(rangeEl.step || 1);
    const cur = Number(rangeEl.value);
    let next = cur + dir * step;

    if (key === "hdg" || key === "gwd" || key === "set") next = wrap360(next);

    const min = Number(rangeEl.min), max = Number(rangeEl.max);
    if (!(key === "hdg" || key === "gwd" || key === "set")) next = Math.min(max, Math.max(min, next));

    rangeEl.value = String(next);
    numEl.value = String(next);
    recalc();
  }

  inputs.hdgM.addEventListener("click", () => nudge("hdg", -1));
  inputs.hdgP.addEventListener("click", () => nudge("hdg", +1));
  inputs.gwdM.addEventListener("click", () => nudge("gwd", -1));
  inputs.gwdP.addEventListener("click", () => nudge("gwd", +1));
  inputs.gwsM.addEventListener("click", () => nudge("gws", -1));
  inputs.gwsP.addEventListener("click", () => nudge("gws", +1));
  inputs.setM.addEventListener("click", () => nudge("set", -1));
  inputs.setP.addEventListener("click", () => nudge("set", +1));
  inputs.driftM.addEventListener("click", () => nudge("drift", -1));
  inputs.driftP.addEventListener("click", () => nudge("drift", +1));

  function setDefaults() {
    inputs.hdg.value = "318"; inputs.hdgN.value = "318";
    inputs.gwd.value = "0";   inputs.gwdN.value = "0";
    inputs.gws.value = "14";  inputs.gwsN.value = "14";
    inputs.set.value = "0";   inputs.setN.value = "0";
    inputs.drift.value = "0"; inputs.driftN.value = "0";

    // default mode/tack
    inputs.modeFree.checked = true;
    inputs.modeVmgUp.checked = false;
    inputs.modeVmgDn.checked = false;
    inputs.tackStbd.checked = true;
    inputs.tackPort.checked = false;

    state.mode = "free";
    state.tack = +1;

    updateModeUI();
  }

  function setDeltaCell(cell, delta, isAngle=false, digits=2) {
    cell.classList.remove("pos", "neg", "zero");
    if (!Number.isFinite(delta)) { cell.textContent = "—"; cell.classList.add("zero"); return; }
    const eps = isAngle ? 0.5 : 1e-9;
    if (Math.abs(delta) < eps) { cell.textContent = "0"; cell.classList.add("zero"); return; }
    const sign = delta > 0 ? "+" : "";
    const txt = isAngle ? `${sign}${delta.toFixed(0)}°` : `${sign}${delta.toFixed(digits)}`;
    cell.textContent = txt;
    cell.classList.add(delta > 0 ? "pos" : "neg");
  }

  function setBaseCell(cell, txt) {
    cell.classList.remove("zero");
    cell.textContent = txt;
    if (txt === "—") cell.classList.add("zero");
  }

  function clearDeltasAndBaselineCols() {
    // baseline col
    for (const k of ["bspB","cogB","sogB","awaB","awsB","twaB","twsB","twdB","setDriftB","gwdGwsB"]) setBaseCell(out[k], "—");
    // delta col
    for (const k of ["bspD","cogD","sogD","awaD","awsD","twaD","twsD","twdD","setDriftD","gwdGwsD"]) {
      out[k].textContent = "—";
      out[k].className = "mono delta zero";
    }
  }

  function setBaselineSnapshot(snap) {
    state.baseline = { ...snap };
    const t = new Date();
    inputs.baselineInfo.textContent =
      `baseline @ ${t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'})}`;
  }

  inputs.baseline.addEventListener("click", () => {
    recalc(false);
    if (state.lastComputed) setBaselineSnapshot(state.lastComputed);
    recalc(false);
  });

  inputs.reset.addEventListener("click", () => {
    setDefaults();
    state.baseline = null;
    state.lastComputed = null;
    inputs.baselineInfo.textContent = "";
    recalc(true);
  });

  function updateModeUI() {
    const showHdg = (state.mode === "free");
    inputs.hdgBlock.style.display = showHdg ? "" : "none";

    const tackEnabled = !showHdg;
    inputs.tackGroup.setAttribute("aria-disabled", tackEnabled ? "false" : "true");
  }

  function setMode(mode) {
    state.mode = mode;
    updateModeUI();
    recalc(false);
  }

  function setTack(sign) {
    state.tack = sign;
    recalc(false);
  }

  inputs.modeFree.addEventListener("change", () => inputs.modeFree.checked && setMode("free"));
  inputs.modeVmgUp.addEventListener("change", () => inputs.modeVmgUp.checked && setMode("vmgUp"));
  inputs.modeVmgDn.addEventListener("change", () => inputs.modeVmgDn.checked && setMode("vmgDn"));

  inputs.tackPort.addEventListener("change", () => inputs.tackPort.checked && setTack(-1));
  inputs.tackStbd.addEventListener("change", () => inputs.tackStbd.checked && setTack(+1));

  function recalc(resetDelta=false) {
    readTheme();

    let HDG = Number(inputs.hdg.value);

    const GWD_from = Number(inputs.gwd.value);
    const GWS = Number(inputs.gws.value);

    const SET_to = Number(inputs.set.value);
    const DRIFT = Number(inputs.drift.value);

    // current (TO)
    const V_cur = vecFromBearingTo(SET_to, DRIFT);

    // ground wind (TO)
    const V_gw_to = windVecFromDirFrom(GWD_from, GWS);

    // true wind over water (TO) (independent of BSP)
    const V_tw_to = { x: V_gw_to.x - V_cur.x, y: V_gw_to.y - V_cur.y };
    const TWS = Math.hypot(V_tw_to.x, V_tw_to.y);
    const TWD_from = windDirFromVec(V_tw_to);

    // MODE LOGIC 
    // VMG modes: take target TWA from polar (based on current TWS), choose tack, then derive HDG.
    if (state.mode === "vmgUp" || state.mode === "vmgDn") {
      const which = (state.mode === "vmgUp") ? "up" : "dn";
      const targetAbs = polarVMGPoint(TWS, which).twa;
      const targetTWA = state.tack * targetAbs; // +stbd, -port

      // TWA = angDiffDeg(TWD_from, HDG)  =>  HDG = TWD_from - TWA
      HDG = wrap360(TWD_from - targetTWA);

      // keep UI in sync (even if hidden)
      inputs.hdg.value = String(Math.round(HDG));
      inputs.hdgN.value = String(Math.round(HDG));
    }

    // TWA in boat frame (FROM)
    const V_tw_boat = vecNEToBoat(V_tw_to, HDG);
    const V_tw_from_boat = { x: -V_tw_boat.x, y: -V_tw_boat.y };
    const TWA = relAngleDegFromBoatVec(V_tw_from_boat);

    // BSP from polar
    const BSP = polarBSP(TWS, TWA);

    // boat through water (TO)
    const V_bw = vecFromBearingTo(HDG, BSP);

    // ground velocity
    const V_bg = { x: V_bw.x + V_cur.x, y: V_bw.y + V_cur.y };
    const bg = bearingToFromVec(V_bg);
    const COG = bg.bearing;
    const SOG = bg.speed;

    // apparent wind at the boat (TO)
    const V_aw_to = { x: V_gw_to.x - V_bg.x, y: V_gw_to.y - V_bg.y };
    const V_aw_boat_to = vecNEToBoat(V_aw_to, HDG);
    const V_aw_from_boat = { x: -V_aw_boat_to.x, y: -V_aw_boat_to.y };

    const AWS = Math.hypot(V_aw_boat_to.x, V_aw_boat_to.y);
    const AWA = relAngleDegFromBoatVec(V_aw_from_boat);

    // outputs (value)
    out.bspOut.textContent = `${fmt(BSP, 2)} kn`;

    out.cog.textContent = fmtDeg(COG);
    out.sog.textContent = `${fmt(SOG, 2)} kn`;

    out.awa.textContent = `${fmtDegSigned(AWA)} (${AWA >= 0 ? "stbd" : "port"})`;
    out.aws.textContent = `${fmt(AWS, 2)} kn`;

    out.twa.textContent = `${fmtDegSigned(TWA)} (${TWA >= 0 ? "stbd" : "port"})`;
    out.twsOut.textContent = `${fmt(TWS, 2)} kn`;
    out.twdOut.textContent = fmtDeg(TWD_from);

    out.setDrift.textContent = `${fmtDeg(SET_to)} / ${fmt(DRIFT, 2)} kn`;
    out.gwdGwsEcho.textContent = `${fmtDeg(GWD_from)} / ${fmt(GWS, 2)} kn`;

    const snap = { BSP, COG, SOG, AWA, AWS, TWA, TWS, TWD_from, SET_to, DRIFT, GWD_from, GWS };
    state.lastComputed = snap;

    if (resetDelta) {
      clearDeltasAndBaselineCols();
    } else if (!state.baseline) {
      clearDeltasAndBaselineCols();
    } else {
      const b = state.baseline;

      // baseline column
      setBaseCell(out.bspB, `${fmt(b.BSP,2)} kn`);

      setBaseCell(out.cogB, `${fmtDeg(b.COG)}`);
      setBaseCell(out.sogB, `${fmt(b.SOG,2)} kn`);
      setBaseCell(out.awaB, `${fmtDegSigned(b.AWA)}`);
      setBaseCell(out.awsB, `${fmt(b.AWS,2)} kn`);
      setBaseCell(out.twaB, `${fmtDegSigned(b.TWA)}`);
      setBaseCell(out.twsB, `${fmt(b.TWS,2)} kn`);
      setBaseCell(out.twdB, `${fmtDeg(b.TWD_from)}`);
      setBaseCell(out.setDriftB, `${fmtDeg(b.SET_to)} / ${fmt(b.DRIFT,2)} kn`);
      setBaseCell(out.gwdGwsB, `${fmtDeg(b.GWD_from)} / ${fmt(b.GWS,2)} kn`);

      // deltas vs baseline
      setDeltaCell(out.bspD, BSP - b.BSP, false, 2);

      setDeltaCell(out.cogD, angDiffDeg(COG, b.COG), true);
      setDeltaCell(out.sogD, SOG - b.SOG, false, 2);

      setDeltaCell(out.awaD, AWA - b.AWA, true);
      setDeltaCell(out.awsD, AWS - b.AWS, false, 2);

      setDeltaCell(out.twaD, TWA - b.TWA, true);
      setDeltaCell(out.twsD, TWS - b.TWS, false, 2);
      setDeltaCell(out.twdD, angDiffDeg(TWD_from, b.TWD_from), true);

      // SET/DRIFT combined
      const dSet = angDiffDeg(SET_to, b.SET_to);
      const dDrift = DRIFT - b.DRIFT;
      out.setDriftD.classList.remove("pos","neg","zero");
      const s1 = (Math.abs(dSet) < 0.5) ? "0°" : `${dSet > 0 ? "+" : ""}${dSet.toFixed(0)}°`;
      const s2 = (Math.abs(dDrift) < 1e-9) ? "0" : `${dDrift > 0 ? "+" : ""}${dDrift.toFixed(2)}`;
      out.setDriftD.textContent = `${s1} / ${s2}`;
      if (Math.abs(dDrift) < 1e-9) out.setDriftD.classList.add("zero");
      else out.setDriftD.classList.add(dDrift > 0 ? "pos" : "neg");

      // GWD/GWS combined
      const dGwd = angDiffDeg(GWD_from, b.GWD_from);
      const dGws = GWS - b.GWS;
      out.gwdGwsD.classList.remove("pos","neg","zero");
      const g1 = (Math.abs(dGwd) < 0.5) ? "0°" : `${dGwd > 0 ? "+" : ""}${dGwd.toFixed(0)}°`;
      const g2 = (Math.abs(dGws) < 1e-9) ? "0" : `${dGws > 0 ? "+" : ""}${dGws.toFixed(2)}`;
      out.gwdGwsD.textContent = `${g1} / ${g2}`;
      if (Math.abs(dGws) < 1e-9) out.gwdGwsD.classList.add("zero");
      else out.gwdGwsD.classList.add(dGws > 0 ? "pos" : "neg");
    }

    drawCanvas({
      HDG,
      V_bw,
      V_cur,
      V_bg,
      V_aw_to,   // TO (arrow points where wind goes)
      V_gw_to,   // TO
      GWD_from,
      GWS
    });

    drawPolarCanvas({
      TWS,
      TWA,
      BSP
    });
  }

  // ---------- vector canvas ----------
  const cv = el("cv");
  const ctx = cv.getContext("2d");

  function drawArrow(origin, vNE, scale, label, style={}) {
    const ox = origin.x, oy = origin.y;
    const x = ox + vNE.x * scale;
    const y = oy - vNE.y * scale;

    ctx.save();
    ctx.strokeStyle = style.stroke || state.theme.vec;
    ctx.fillStyle = style.fill || state.theme.vec;
    ctx.lineWidth = style.width ?? 2;
    ctx.globalAlpha = style.alpha ?? 1;
    if (style.dash) ctx.setLineDash(style.dash);

    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(x, y);
    ctx.stroke();

    const ang = Math.atan2(y - oy, x - ox);
    const ah = style.head ?? 10;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - ah * Math.cos(ang - Math.PI/7), y - ah * Math.sin(ang - Math.PI/7));
    ctx.lineTo(x - ah * Math.cos(ang + Math.PI/7), y - ah * Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();

    if (label) {
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.fillText(label, x + 6, y + 4);
    }
    ctx.restore();
  }

  function drawBoat(origin, hdgDeg) {
    ctx.save();
    ctx.translate(origin.x, origin.y);
    ctx.rotate(deg2rad(hdgDeg));
    ctx.strokeStyle = state.theme.vec;

    // simple hull
    const L = 26, W = 14;
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -L);
    ctx.lineTo(W, L * 0.65);
    ctx.lineTo(0, L * 0.35);
    ctx.lineTo(-W, L * 0.65);
    ctx.closePath();
    ctx.stroke();

    // centerline
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -L - 8);
    ctx.stroke();

    ctx.restore();
  }

  function drawInsetWind(box, V_gw_to, GWD_from, GWS) {
    ctx.save();

    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = state.theme.grid;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(box.x, box.y, box.w, box.h, 10);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = state.theme.vec;
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText(`GWD/GWS ${wrap360(GWD_from).toFixed(0)}° / ${Number(GWS).toFixed(1)} kn`, box.x + 10, box.y + 18);

    const cx = box.x + box.w * 0.5;
    const cy = box.y + box.h * 0.62;

    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(box.x + 10, cy); ctx.lineTo(box.x + box.w - 10, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, box.y + 30); ctx.lineTo(cx, box.y + box.h - 10); ctx.stroke();

    const maxSpd = Math.max(1, Math.hypot(V_gw_to.x, V_gw_to.y));
    const scale = (Math.min(box.w, box.h) * 0.28) / maxSpd;

    // GW arrow points TO (downwind)
    drawArrow({ x: cx, y: cy }, V_gw_to, scale, "GW", { width: 2, alpha: 1 });

    ctx.restore();
  }

  function drawCanvas(s) {
    const { HDG, V_bw, V_cur, V_bg, V_aw_to, V_gw_to, GWD_from, GWS } = s;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = cv.clientWidth, cssH = cv.clientHeight;
    const W = Math.floor(cssW * dpr), H = Math.floor(cssH * dpr);
    if (cv.width !== W || cv.height !== H) { cv.width = W; cv.height = H; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.clearRect(0, 0, cssW, cssH);

    const origin = { x: cssW * 0.42, y: cssH * 0.62 };

    // grid
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(cssW, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, cssH); ctx.stroke();
    ctx.restore();

    const maxSpd = Math.max(
      1,
      Math.hypot(V_bg.x, V_bg.y),
      Math.hypot(V_bw.x, V_bw.y),
      Math.hypot(V_cur.x, V_cur.y),
      Math.hypot(V_aw_to.x, V_aw_to.y)
    );
    const scale = (Math.min(cssW, cssH) * 0.34) / maxSpd;

    drawArrow(origin, V_bg,   scale, "COG", { width: 3, alpha: 1 });
    drawArrow(origin, V_bw,   scale, "BSP", { width: 2, alpha: 0.7, dash: [8, 6] });
    drawArrow(origin, V_cur,  scale, "cur", { width: 2, alpha: 0.55, dash: [2, 6] });

    // AW arrow points TO (wind velocity)
    const awOrigin = { x: origin.x, y: origin.y };
    drawArrow(awOrigin, V_aw_to, scale, "AW", { width: 1, alpha: 0.3 });

    drawBoat(origin, HDG);

    const box = { x: cssW - 240, y: 16, w: 224, h: 150 };
    drawInsetWind(box, V_gw_to, GWD_from, GWS);
  }

  // ---------- polar canvas ----------
  const polarCv = el("polarCv");
  const pctx = polarCv.getContext("2d");

  function drawPolarCanvas(s) {
    const { TWS, TWA, BSP } = s;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = polarCv.clientWidth, cssH = polarCv.clientHeight;
    const W = Math.floor(cssW * dpr), H = Math.floor(cssH * dpr);
    if (polarCv.width !== W || polarCv.height !== H) { polarCv.width = W; polarCv.height = H; }
    pctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    pctx.clearRect(0, 0, cssW, cssH);

    const pad = { l: 48, r: 18, t: 16, b: 34 };
    const plotW = cssW - pad.l - pad.r;
    const plotH = cssH - pad.t - pad.b;

    // y max from polar (a bit padded)
    let yMax = 1;
    for (const r of POLAR_ROWS) for (const pt of r.points) yMax = Math.max(yMax, pt.bsp);
    yMax = Math.ceil((yMax + 0.6) * 2) / 2;

    const xMin = 0, xMax = 180;
    const xToPx = x => pad.l + (clamp(x, xMin, xMax) - xMin) / (xMax - xMin) * plotW;
    const yToPx = y => pad.t + (1 - clamp(y, 0, yMax) / yMax) * plotH;

    // axes + grid
    pctx.save();
    pctx.strokeStyle = state.theme.grid;
    pctx.fillStyle = state.theme.vec;

    pctx.globalAlpha = 0.55;
    pctx.lineWidth = 1;

    // vertical grid every 30°
    for (let x = 0; x <= 180; x += 30) {
      const px = xToPx(x);
      pctx.beginPath(); pctx.moveTo(px, pad.t); pctx.lineTo(px, pad.t + plotH); pctx.stroke();
    }
    // horizontal grid every 2 kn
    const yStep = 2;
    for (let y = 0; y <= yMax + 1e-9; y += yStep) {
      const py = yToPx(y);
      pctx.beginPath(); pctx.moveTo(pad.l, py); pctx.lineTo(pad.l + plotW, py); pctx.stroke();
    }

    // axes
    pctx.globalAlpha = 0.85;
    pctx.beginPath(); pctx.moveTo(pad.l, pad.t); pctx.lineTo(pad.l, pad.t + plotH); pctx.stroke();
    pctx.beginPath(); pctx.moveTo(pad.l, pad.t + plotH); pctx.lineTo(pad.l + plotW, pad.t + plotH); pctx.stroke();

    // labels
    pctx.globalAlpha = 1;
    pctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    <!-- pctx.fillText("TWA (abs)", pad.l, cssH - 2); -->
    <!-- pctx.fillText("BSP", 10, pad.t + 12); -->

    // tick labels
    pctx.globalAlpha = 0.9;
    for (let x = 0; x <= 180; x += 30) {
      const px = xToPx(x);
      pctx.fillText(`${x}°`, px - 10, pad.t + plotH + 18);
    }
    for (let y = 0; y <= yMax + 1e-9; y += yStep) {
      const py = yToPx(y);
      pctx.fillText(`${y.toFixed(0)}`, 16, py + 4);
    }

    // header
    pctx.globalAlpha = 1;
    pctx.fillText(`POLAR  (TWS≈${fmt(TWS,1)} kn)`, pad.l, 14);

    // thin curves for each discrete row
    pctx.globalAlpha = 0.35;
    pctx.lineWidth = 2;
    pctx.setLineDash([6, 6]);
    for (const r of POLAR_ROWS) {
      pctx.beginPath();
      const pts = r.points;
      for (let i = 0; i < pts.length; i++) {
        const px = xToPx(pts[i].twa);
        const py = yToPx(pts[i].bsp);
        if (i === 0) pctx.moveTo(px, py);
        else pctx.lineTo(px, py);
      }
      pctx.strokeStyle = state.theme.vec;
      pctx.stroke();
    }

    // thick interpolated curve at current TWS
    pctx.globalAlpha = 0.95;
    pctx.lineWidth = 3;
    pctx.setLineDash([]);
    pctx.beginPath();
    for (let x = 0; x <= 180; x += 2) {
      const y = polarBSP(TWS, x);
      const px = xToPx(x);
      const py = yToPx(y);
      if (x === 0) pctx.moveTo(px, py);
      else pctx.lineTo(px, py);
    }
    pctx.strokeStyle = state.theme.vec;
    pctx.stroke();

    // VMG markers (interpolated)
    const up = polarVMGPoint(TWS, "up");
    const dn = polarVMGPoint(TWS, "dn");

    function drawMarker(px, py, kind) {
      pctx.save();
      pctx.translate(px, py);
      pctx.fillStyle = state.theme.vec;
      pctx.strokeStyle = state.theme.vec;
      pctx.globalAlpha = 0.95;

      // small triangle
      const s = 7;
      pctx.beginPath();
      if (kind === "up") {
        pctx.moveTo(0, -s);
        pctx.lineTo(s, s);
        pctx.lineTo(-s, s);
      } else {
        pctx.moveTo(0, s);
        pctx.lineTo(s, -s);
        pctx.lineTo(-s, -s);
      }
      pctx.closePath();
      pctx.fill();

      pctx.restore();
    }

    drawMarker(xToPx(up.twa), yToPx(up.bsp), "up");
    drawMarker(xToPx(dn.twa), yToPx(dn.bsp), "dn");

    // current point (abs(TWA), BSP)
    const xCur = clamp(Math.abs(TWA), 0, 180);
    const pxCur = xToPx(xCur);
    const pyCur = yToPx(BSP);

    pctx.globalAlpha = 1;
    pctx.beginPath();
    pctx.arc(pxCur, pyCur, 5, 0, Math.PI * 2);
    pctx.fillStyle = state.theme.vec;
    pctx.fill();

    // annotation
    pctx.globalAlpha = 0.95;
    pctx.fillStyle = state.theme.vec;
    const label = `TWA ${xCur.toFixed(1)}°  BSP ${fmt(BSP,2)} kn`;
    <!-- pctx.fillText(label, Math.min(pxCur - 10, pad.l + plotW - 220), Math.max(pyCur - 10, pad.t + 14)); -->
    pctx.fillText(label, pad.l+plotW-200, 14);

    pctx.restore();
  }

  // ---------- init ----------
  setDefaults();
  readTheme();
  recalc(true);

  window.addEventListener("resize", () => recalc(false));
  const mq = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)");
  if (mq && mq.addEventListener) mq.addEventListener("change", () => recalc(false));
})();
</script>
</body>
</html>
