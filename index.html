<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sailing Processor Model (Single File)</title>
  <style>
    :root {
      color-scheme: light dark;

      --border: rgba(127,127,127,.35);
      --border2: rgba(127,127,127,.25);
      --bgCanvas: rgba(127,127,127,.06);

      --vec: rgba(30,30,30,.92);
      --grid: rgba(127,127,127,.45);
      --hdg: rgba(127,127,127,.85);

      --pos: #1a8f3a;
      --neg: #c62828;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --border: rgba(255,255,255,.18);
        --border2: rgba(255,255,255,.12);
        --bgCanvas: rgba(255,255,255,.06);

        --vec: rgba(245,245,245,.92);
        --grid: rgba(255,255,255,.22);
        --hdg: rgba(255,255,255,.60);

        --pos: #47d16a;
        --neg: #ff5a5a;
      }
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 18px; font-weight: 650; }
    .grid { display: grid; grid-template-columns: 420px 1fr; gap: 16px; align-items: start; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; margin: 10px 0; }
    label { font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 100%; }

    input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }

    .small { font-size: 12px; opacity: .85; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 6px 8px; border-bottom: 1px solid var(--border2); }
    th { text-align: left; font-weight: 650; opacity: .9; }
    td:first-child { opacity: .85; width: 28%; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; border:1px solid var(--border); font-size: 12px; }
    .toolbar { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-top: 8px; }
    canvas { width: 100%; height: 420px; border-radius: 12px; border: 1px solid var(--border); background: var(--bgCanvas); display:block; }

    .numCtl { display: grid; grid-template-columns: 52px 1fr 52px; gap: 8px; align-items: center; }
    .pmBtn { padding: 10px 0; font-weight: 700; font-size: 18px; line-height: 1; }

    .delta { opacity: .9; }
    .delta.mono, .base.mono { font-variant-numeric: tabular-nums; }
    .delta.pos { color: var(--pos); }
    .delta.neg { color: var(--neg); }
    .delta.zero, .base.zero { opacity: .55; }
  </style>
</head>
<body>
  <h1>Sailing Processor Model</h1>

  <div class="grid">
    <div class="card">
      <div class="small">
        Inputs: <span class="mono">GWD, GWS, HDG, SET, DRIFT</span>.
        <br/>
        Wind dirs are <span class="mono">FROM</span>, boat/current dirs are <span class="mono">TO</span>.
        <br/>
        <span class="mono">BSP</span> comes from a demo polar (edit it in JS).
      </div>

      <div class="toolbar">
        <span class="pill">deg</span>
        <span class="pill">kn</span>
      </div>

      <hr style="border:none;border-top:1px solid var(--border2); margin: 12px 0;" />

      <!-- HDG -->
      <div class="row">
        <label for="hdg">HDG</label>
        <div class="numCtl">
          <button class="pmBtn" id="hdgM" aria-label="HDG minus">−</button>
          <input id="hdgN" type="number" step="1" />
          <button class="pmBtn" id="hdgP" aria-label="HDG plus">+</button>
        </div>
      </div>
      <input id="hdg" type="range" min="0" max="359" step="1" />

      <!-- GWD -->
      <div class="row">
        <label for="gwd">GWD</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwdM" aria-label="GWD minus">−</button>
          <input id="gwdN" type="number" step="1" />
          <button class="pmBtn" id="gwdP" aria-label="GWD plus">+</button>
        </div>
      </div>
      <input id="gwd" type="range" min="0" max="359" step="1" />

      <!-- GWS -->
      <div class="row">
        <label for="gws">GWS</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwsM" aria-label="GWS minus">−</button>
          <input id="gwsN" type="number" step="1" />
          <button class="pmBtn" id="gwsP" aria-label="GWS plus">+</button>
        </div>
      </div>
      <input id="gws" type="range" min="0" max="60" step="1" />

      <!-- SET -->
      <div class="row">
        <label for="set">SET</label>
        <div class="numCtl">
          <button class="pmBtn" id="setM" aria-label="SET minus">−</button>
          <input id="setN" type="number" step="1" />
          <button class="pmBtn" id="setP" aria-label="SET plus">+</button>
        </div>
      </div>
      <input id="set" type="range" min="0" max="359" step="1" />

      <!-- DRIFT -->
      <div class="row">
        <label for="drift">DRIFT</label>
        <div class="numCtl">
          <button class="pmBtn" id="driftM" aria-label="DRIFT minus">−</button>
          <input id="driftN" type="number" step="1" />
          <button class="pmBtn" id="driftP" aria-label="DRIFT plus">+</button>
        </div>
      </div>
      <input id="drift" type="range" min="0" max="12" step="1" />

      <div class="toolbar">
        <button id="baseline">Set baseline</button>
        <button id="reset">Reset</button>
        <span class="small" id="baselineInfo" style="margin-left:auto;"></span>
      </div>

      <div class="small" style="margin-top:10px;">
        AWA/TWA are signed in boat frame:
        <br/>• <span class="mono">+</span> stbd, <span class="mono">-</span> port
        <br/>• 0° = wind from straight ahead
      </div>
    </div>

    <div class="card">
      <table>
        <thead>
          <tr>
            <th>Key</th>
            <th class="mono">Baseline</th>
            <th class="mono">Value</th>
            <th class="mono">Δ</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>BSP</td><td class="mono base" id="bspB"></td><td class="mono" id="bspOut"></td><td class="mono delta" id="bspD"></td></tr>

          <tr><td>COG</td><td class="mono base" id="cogB"></td><td class="mono" id="cog"></td><td class="mono delta" id="cogD"></td></tr>
          <tr><td>SOG</td><td class="mono base" id="sogB"></td><td class="mono" id="sog"></td><td class="mono delta" id="sogD"></td></tr>

          <tr><td>AWA</td><td class="mono base" id="awaB"></td><td class="mono" id="awa"></td><td class="mono delta" id="awaD"></td></tr>
          <tr><td>AWS</td><td class="mono base" id="awsB"></td><td class="mono" id="aws"></td><td class="mono delta" id="awsD"></td></tr>

          <tr><td>TWA</td><td class="mono base" id="twaB"></td><td class="mono" id="twa"></td><td class="mono delta" id="twaD"></td></tr>
          <tr><td>TWS</td><td class="mono base" id="twsB"></td><td class="mono" id="twsOut"></td><td class="mono delta" id="twsD"></td></tr>
          <tr><td>TWD</td><td class="mono base" id="twdB"></td><td class="mono" id="twdOut"></td><td class="mono delta" id="twdD"></td></tr>

          <tr><td>SET/DRIFT</td><td class="mono base" id="setDriftB"></td><td class="mono" id="setDrift"></td><td class="mono delta" id="setDriftD"></td></tr>
          <tr><td>GWD/GWS</td><td class="mono base" id="gwdGwsB"></td><td class="mono" id="gwdGwsEcho"></td><td class="mono delta" id="gwdGwsD"></td></tr>
        </tbody>
      </table>

      <div style="margin-top:10px;">
        <canvas id="cv" width="980" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const deg2rad = d => d * Math.PI / 180;
  const rad2deg = r => r * 180 / Math.PI;
  const wrap360 = d => (d % 360 + 360) % 360;

  function angDiffDeg(a, b) {
    let d = ((a - b + 540) % 360) - 180;
    if (d === -180) d = 180;
    return d;
  }

  function vecFromBearingTo(bearingDeg, speed) {
    const a = deg2rad(bearingDeg);
    return { x: speed * Math.sin(a), y: speed * Math.cos(a) };
  }

  function bearingToFromVec(v) {
    const spd = Math.hypot(v.x, v.y);
    const brg = wrap360(rad2deg(Math.atan2(v.x, v.y)));
    return { bearing: brg, speed: spd };
  }

  function vecNEToBoat(vNE, hdgDeg) {
    const a = deg2rad(hdgDeg);
    const forward =  vNE.x * Math.sin(a) + vNE.y * Math.cos(a);
    const starbd =  vNE.x * Math.cos(a) - vNE.y * Math.sin(a);
    return { x: forward, y: starbd };
  }

  function windVecFromDirFrom(dirFromDeg, speed) {
    // returns wind velocity vector pointing TO (downwind)
    return vecFromBearingTo(wrap360(dirFromDeg + 180), speed);
  }

  function windDirFromVec(vTo) {
    // given wind velocity vector TO, return direction FROM
    const { bearing } = bearingToFromVec(vTo);
    return wrap360(bearing + 180);
  }

  function relAngleDegFromBoatVec(vBoat) {
    const ang = rad2deg(Math.atan2(vBoat.y, vBoat.x));
    return ((ang + 180) % 360) - 180;
  }

  const fmt = (x, digits=1) => Number.isFinite(x) ? x.toFixed(digits) : "—";
  const fmtDeg = (d) => Number.isFinite(d) ? `${wrap360(d).toFixed(0)}°` : "—";
  const fmtDegSigned = (d) => Number.isFinite(d) ? `${d.toFixed(0)}°` : "—";

  const el = id => document.getElementById(id);

  // ---------- demo polar (edit this for your boat) ----------
  // angles in deg (0..180), speeds in kn
  const POLAR_TWA = [0, 30, 45, 60, 90, 120, 150, 180];
  const POLAR_TWS = [6, 10, 14, 18, 22];

  // rows correspond to POLAR_TWS, columns to POLAR_TWA
  // NOTE: this is just a smooth-ish placeholder. Replace with your real polar.
  const POLAR_BSP = [
    // TWS=6
    [0, 5.6, 6.1, 6.3, 6.4, 6.0, 5.2, 0],
    // TWS=10
    [0, 6.6, 7.3, 7.8, 8.1, 7.9, 7.0, 0],
    // TWS=14
    [0, 7.4, 8.2, 8.8, 9.3, 9.6, 9.0, 0],
    // TWS=18
    [0, 7.9, 8.8, 9.5, 10.2, 10.8, 10.4, 0],
    // TWS=22
    [0, 8.1, 9.0, 9.7, 10.6, 11.4, 11.2, 0],
  ];

  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  function findSpan(arr, x) {
    if (x <= arr[0]) return { i0: 0, i1: 0, t: 0 };
    if (x >= arr[arr.length - 1]) {
      const i = arr.length - 1;
      return { i0: i, i1: i, t: 0 };
    }
    for (let i = 0; i < arr.length - 1; i++) {
      if (x >= arr[i] && x <= arr[i + 1]) {
        const t = (x - arr[i]) / (arr[i + 1] - arr[i]);
        return { i0: i, i1: i + 1, t };
      }
    }
    return { i0: 0, i1: 0, t: 0 };
  }

  // bilinear interpolation over (TWS, TWA)
  function polarBSP(tws, twaAbs) {
    const twa = clamp(Math.abs(twaAbs), 0, 180);
    const { i0: w0, i1: w1, t: tw } = findSpan(POLAR_TWS, tws);
    const { i0: a0, i1: a1, t: ta } = findSpan(POLAR_TWA, twa);

    const f00 = POLAR_BSP[w0][a0];
    const f01 = POLAR_BSP[w0][a1];
    const f10 = POLAR_BSP[w1][a0];
    const f11 = POLAR_BSP[w1][a1];

    const f0 = lerp(f00, f01, ta);
    const f1 = lerp(f10, f11, ta);
    return lerp(f0, f1, tw);
  }

  // ---------- UI refs ----------
  const inputs = {
    hdg: el("hdg"), hdgN: el("hdgN"), hdgM: el("hdgM"), hdgP: el("hdgP"),
    gwd: el("gwd"), gwdN: el("gwdN"), gwdM: el("gwdM"), gwdP: el("gwdP"),
    gws: el("gws"), gwsN: el("gwsN"), gwsM: el("gwsM"), gwsP: el("gwsP"),
    set: el("set"), setN: el("setN"), setM: el("setM"), setP: el("setP"),
    drift: el("drift"), driftN: el("driftN"), driftM: el("driftM"), driftP: el("driftP"),
    baseline: el("baseline"),
    baselineInfo: el("baselineInfo"),
    reset: el("reset")
  };

  const out = {
    bspOut: el("bspOut"),
    cog: el("cog"), sog: el("sog"),
    awa: el("awa"), aws: el("aws"),
    twa: el("twa"), twsOut: el("twsOut"), twdOut: el("twdOut"),
    setDrift: el("setDrift"),
    gwdGwsEcho: el("gwdGwsEcho"),

    bspD: el("bspD"),
    cogD: el("cogD"), sogD: el("sogD"),
    awaD: el("awaD"), awsD: el("awsD"),
    twaD: el("twaD"), twsD: el("twsD"), twdD: el("twdD"),
    setDriftD: el("setDriftD"),
    gwdGwsD: el("gwdGwsD"),

    // baseline column
    bspB: el("bspB"),
    cogB: el("cogB"), sogB: el("sogB"),
    awaB: el("awaB"), awsB: el("awsB"),
    twaB: el("twaB"), twsB: el("twsB"), twdB: el("twdB"),
    setDriftB: el("setDriftB"),
    gwdGwsB: el("gwdGwsB"),
  };

  const state = {
    baseline: null,
    lastComputed: null,
    theme: null
  };

  function readTheme() {
    const cs = getComputedStyle(document.documentElement);
    state.theme = {
      vec: cs.getPropertyValue("--vec").trim() || "rgba(30,30,30,.92)",
      grid: cs.getPropertyValue("--grid").trim() || "rgba(127,127,127,.45)",
      hdg: cs.getPropertyValue("--hdg").trim() || "rgba(127,127,127,.85)",
    };
  }

  function bindRangeAndNumber(rangeEl, numEl) {
    function clampToRange(v) {
      const min = Number(rangeEl.min), max = Number(rangeEl.max);
      if (!Number.isFinite(v)) return Number(rangeEl.value);
      return Math.min(max, Math.max(min, v));
    }
    function syncFromRange() { numEl.value = rangeEl.value; recalc(); }
    function syncFromNum() {
      const v = clampToRange(Number(numEl.value));
      rangeEl.value = String(v);
      numEl.value = String(v);
      recalc();
    }
    rangeEl.addEventListener("input", syncFromRange);
    numEl.addEventListener("input", syncFromNum);
  }

  bindRangeAndNumber(inputs.hdg, inputs.hdgN);
  bindRangeAndNumber(inputs.gwd, inputs.gwdN);
  bindRangeAndNumber(inputs.gws, inputs.gwsN);
  bindRangeAndNumber(inputs.set, inputs.setN);
  bindRangeAndNumber(inputs.drift, inputs.driftN);

  function nudge(key, dir) {
    const rangeEl = inputs[key];
    const numEl = inputs[key + "N"];
    const step = Number(rangeEl.step || 1);
    const cur = Number(rangeEl.value);
    let next = cur + dir * step;

    if (key === "hdg" || key === "gwd" || key === "set") next = wrap360(next);

    const min = Number(rangeEl.min), max = Number(rangeEl.max);
    if (!(key === "hdg" || key === "gwd" || key === "set")) next = Math.min(max, Math.max(min, next));

    rangeEl.value = String(next);
    numEl.value = String(next);
    recalc();
  }

  inputs.hdgM.addEventListener("click", () => nudge("hdg", -1));
  inputs.hdgP.addEventListener("click", () => nudge("hdg", +1));
  inputs.gwdM.addEventListener("click", () => nudge("gwd", -1));
  inputs.gwdP.addEventListener("click", () => nudge("gwd", +1));
  inputs.gwsM.addEventListener("click", () => nudge("gws", -1));
  inputs.gwsP.addEventListener("click", () => nudge("gws", +1));
  inputs.setM.addEventListener("click", () => nudge("set", -1));
  inputs.setP.addEventListener("click", () => nudge("set", +1));
  inputs.driftM.addEventListener("click", () => nudge("drift", -1));
  inputs.driftP.addEventListener("click", () => nudge("drift", +1));

  function setDefaults() {
    inputs.hdg.value = "318"; inputs.hdgN.value = "318";
    inputs.gwd.value = "0";   inputs.gwdN.value = "0";
    inputs.gws.value = "14";  inputs.gwsN.value = "14";
    inputs.set.value = "0";   inputs.setN.value = "0";
    inputs.drift.value = "0"; inputs.driftN.value = "0";
  }

  function setDeltaCell(cell, delta, isAngle=false, digits=2) {
    cell.classList.remove("pos", "neg", "zero");
    if (!Number.isFinite(delta)) { cell.textContent = "—"; cell.classList.add("zero"); return; }
    const eps = isAngle ? 0.5 : 1e-9;
    if (Math.abs(delta) < eps) { cell.textContent = "0"; cell.classList.add("zero"); return; }
    const sign = delta > 0 ? "+" : "";
    const txt = isAngle ? `${sign}${delta.toFixed(0)}°` : `${sign}${delta.toFixed(digits)}`;
    cell.textContent = txt;
    cell.classList.add(delta > 0 ? "pos" : "neg");
  }

  function setBaseCell(cell, txt) {
    cell.classList.remove("zero");
    cell.textContent = txt;
    if (txt === "—") cell.classList.add("zero");
  }

  function clearDeltasAndBaselineCols() {
    // baseline col
    for (const k of ["bspB","cogB","sogB","awaB","awsB","twaB","twsB","twdB","setDriftB","gwdGwsB"]) setBaseCell(out[k], "—");
    // delta col
    for (const k of ["bspD","cogD","sogD","awaD","awsD","twaD","twsD","twdD","setDriftD","gwdGwsD"]) {
      out[k].textContent = "—";
      out[k].className = "mono delta zero";
    }
  }

  function setBaselineSnapshot(snap) {
    state.baseline = { ...snap };
    const t = new Date();
    inputs.baselineInfo.textContent =
      `baseline @ ${t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'})}`;
  }

  inputs.baseline.addEventListener("click", () => {
    recalc(false);
    if (state.lastComputed) setBaselineSnapshot(state.lastComputed);
    recalc(false);
  });

  inputs.reset.addEventListener("click", () => {
    setDefaults();
    state.baseline = null;
    state.lastComputed = null;
    inputs.baselineInfo.textContent = "";
    recalc(true);
  });

  function recalc(resetDelta=false) {
    readTheme();

    const HDG = Number(inputs.hdg.value);

    const GWD_from = Number(inputs.gwd.value);
    const GWS = Number(inputs.gws.value);

    const SET_to = Number(inputs.set.value);
    const DRIFT = Number(inputs.drift.value);

    // current (TO)
    const V_cur = vecFromBearingTo(SET_to, DRIFT);

    // ground wind (TO)
    const V_gw_to = windVecFromDirFrom(GWD_from, GWS);

    // true wind over water (TO) (independent of BSP)
    const V_tw_to = { x: V_gw_to.x - V_cur.x, y: V_gw_to.y - V_cur.y };
    const TWS = Math.hypot(V_tw_to.x, V_tw_to.y);
    const TWD_from = windDirFromVec(V_tw_to);

    // TWA in boat frame (FROM)
    const V_tw_boat = vecNEToBoat(V_tw_to, HDG);
    const V_tw_from_boat = { x: -V_tw_boat.x, y: -V_tw_boat.y };
    const TWA = relAngleDegFromBoatVec(V_tw_from_boat);

    // BSP from polar
    const BSP = polarBSP(TWS, TWA);

    // boat through water (TO)
    const V_bw = vecFromBearingTo(HDG, BSP);

    // ground velocity
    const V_bg = { x: V_bw.x + V_cur.x, y: V_bw.y + V_cur.y };
    const bg = bearingToFromVec(V_bg);
    const COG = bg.bearing;
    const SOG = bg.speed;

    // apparent wind at the boat (TO)
    const V_aw_to = { x: V_gw_to.x - V_bg.x, y: V_gw_to.y - V_bg.y };
    const V_aw_boat_to = vecNEToBoat(V_aw_to, HDG);
    const V_aw_from_boat = { x: -V_aw_boat_to.x, y: -V_aw_boat_to.y };

    const AWS = Math.hypot(V_aw_boat_to.x, V_aw_boat_to.y);
    const AWA = relAngleDegFromBoatVec(V_aw_from_boat);

    // outputs (value)
    out.bspOut.textContent = `${fmt(BSP, 2)} kn`;

    out.cog.textContent = fmtDeg(COG);
    out.sog.textContent = `${fmt(SOG, 2)} kn`;

    out.awa.textContent = `${fmtDegSigned(AWA)} (${AWA >= 0 ? "stbd" : "port"})`;
    out.aws.textContent = `${fmt(AWS, 2)} kn`;

    out.twa.textContent = `${fmtDegSigned(TWA)} (${TWA >= 0 ? "stbd" : "port"})`;
    out.twsOut.textContent = `${fmt(TWS, 2)} kn`;
    out.twdOut.textContent = fmtDeg(TWD_from);

    out.setDrift.textContent = `${fmtDeg(SET_to)} / ${fmt(DRIFT, 2)} kn`;
    out.gwdGwsEcho.textContent = `${fmtDeg(GWD_from)} / ${fmt(GWS, 2)} kn`;

    const snap = { BSP, COG, SOG, AWA, AWS, TWA, TWS, TWD_from, SET_to, DRIFT, GWD_from, GWS };
    state.lastComputed = snap;

    if (resetDelta) {
      clearDeltasAndBaselineCols();
    } else if (!state.baseline) {
      clearDeltasAndBaselineCols();
    } else {
      const b = state.baseline;

      // baseline column
      setBaseCell(out.bspB, `${fmt(b.BSP,2)} kn`);

      setBaseCell(out.cogB, `${fmtDeg(b.COG)}`);
      setBaseCell(out.sogB, `${fmt(b.SOG,2)} kn`);
      setBaseCell(out.awaB, `${fmtDegSigned(b.AWA)}`);
      setBaseCell(out.awsB, `${fmt(b.AWS,2)} kn`);
      setBaseCell(out.twaB, `${fmtDegSigned(b.TWA)}`);
      setBaseCell(out.twsB, `${fmt(b.TWS,2)} kn`);
      setBaseCell(out.twdB, `${fmtDeg(b.TWD_from)}`);
      setBaseCell(out.setDriftB, `${fmtDeg(b.SET_to)} / ${fmt(b.DRIFT,2)} kn`);
      setBaseCell(out.gwdGwsB, `${fmtDeg(b.GWD_from)} / ${fmt(b.GWS,2)} kn`);

      // deltas vs baseline
      setDeltaCell(out.bspD, BSP - b.BSP, false, 2);

      setDeltaCell(out.cogD, angDiffDeg(COG, b.COG), true);
      setDeltaCell(out.sogD, SOG - b.SOG, false, 2);

      setDeltaCell(out.awaD, AWA - b.AWA, true);
      setDeltaCell(out.awsD, AWS - b.AWS, false, 2);

      setDeltaCell(out.twaD, TWA - b.TWA, true);
      setDeltaCell(out.twsD, TWS - b.TWS, false, 2);
      setDeltaCell(out.twdD, angDiffDeg(TWD_from, b.TWD_from), true);

      // SET/DRIFT combined
      const dSet = angDiffDeg(SET_to, b.SET_to);
      const dDrift = DRIFT - b.DRIFT;
      out.setDriftD.classList.remove("pos","neg","zero");
      const s1 = (Math.abs(dSet) < 0.5) ? "0°" : `${dSet > 0 ? "+" : ""}${dSet.toFixed(0)}°`;
      const s2 = (Math.abs(dDrift) < 1e-9) ? "0" : `${dDrift > 0 ? "+" : ""}${dDrift.toFixed(2)}`;
      out.setDriftD.textContent = `${s1} / ${s2}`;
      if (Math.abs(dDrift) < 1e-9) out.setDriftD.classList.add("zero");
      else out.setDriftD.classList.add(dDrift > 0 ? "pos" : "neg");

      // GWD/GWS combined
      const dGwd = angDiffDeg(GWD_from, b.GWD_from);
      const dGws = GWS - b.GWS;
      out.gwdGwsD.classList.remove("pos","neg","zero");
      const g1 = (Math.abs(dGwd) < 0.5) ? "0°" : `${dGwd > 0 ? "+" : ""}${dGwd.toFixed(0)}°`;
      const g2 = (Math.abs(dGws) < 1e-9) ? "0" : `${dGws > 0 ? "+" : ""}${dGws.toFixed(2)}`;
      out.gwdGwsD.textContent = `${g1} / ${g2}`;
      if (Math.abs(dGws) < 1e-9) out.gwdGwsD.classList.add("zero");
      else out.gwdGwsD.classList.add(dGws > 0 ? "pos" : "neg");
    }

    drawCanvas({
      HDG,
      V_bw,
      V_cur,
      V_bg,
      V_aw_to,   // TO (arrow points where wind goes)
      V_gw_to,   // TO
      GWD_from,
      GWS
    });
  }

  // ---------- canvas ----------
  const cv = el("cv");
  const ctx = cv.getContext("2d");

  function drawArrow(origin, vNE, scale, label, style={}) {
    const ox = origin.x, oy = origin.y;
    const x = ox + vNE.x * scale;
    const y = oy - vNE.y * scale;

    ctx.save();
    ctx.strokeStyle = style.stroke || state.theme.vec;
    ctx.fillStyle = style.fill || state.theme.vec;
    ctx.lineWidth = style.width ?? 2;
    ctx.globalAlpha = style.alpha ?? 1;
    if (style.dash) ctx.setLineDash(style.dash);

    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(x, y);
    ctx.stroke();

    const ang = Math.atan2(y - oy, x - ox);
    const ah = style.head ?? 10;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - ah * Math.cos(ang - Math.PI/7), y - ah * Math.sin(ang - Math.PI/7));
    ctx.lineTo(x - ah * Math.cos(ang + Math.PI/7), y - ah * Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();

    if (label) {
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.fillText(label, x + 6, y + 4);
    }
    ctx.restore();
  }

  function drawBoat(origin, hdgDeg) {
    ctx.save();
    ctx.translate(origin.x, origin.y);
    ctx.rotate(deg2rad(hdgDeg));
    ctx.strokeStyle = state.theme.vec;

    // simple hull
    const L = 26, W = 14;
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -L);
    ctx.lineTo(W, L * 0.65);
    ctx.lineTo(0, L * 0.35);
    ctx.lineTo(-W, L * 0.65);
    ctx.closePath();
    ctx.stroke();

    // centerline
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -L - 8);
    ctx.stroke();

    ctx.restore();
  }

  function drawInsetWind(box, V_gw_to, GWD_from, GWS) {
    ctx.save();

    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = state.theme.grid;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(box.x, box.y, box.w, box.h, 10);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = state.theme.vec;
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText(`GWD/GWS ${wrap360(GWD_from).toFixed(0)}° / ${Number(GWS).toFixed(1)} kn`, box.x + 10, box.y + 18);

    const cx = box.x + box.w * 0.5;
    const cy = box.y + box.h * 0.62;

    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(box.x + 10, cy); ctx.lineTo(box.x + box.w - 10, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, box.y + 30); ctx.lineTo(cx, box.y + box.h - 10); ctx.stroke();

    const maxSpd = Math.max(1, Math.hypot(V_gw_to.x, V_gw_to.y));
    const scale = (Math.min(box.w, box.h) * 0.28) / maxSpd;

    // GW arrow points TO (downwind)
    drawArrow({ x: cx, y: cy }, V_gw_to, scale, "GW", { width: 2, alpha: 1 });

    ctx.restore();
  }

  function drawCanvas(s) {
    const { HDG, V_bw, V_cur, V_bg, V_aw_to, V_gw_to, GWD_from, GWS } = s;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = cv.clientWidth, cssH = cv.clientHeight;
    const W = Math.floor(cssW * dpr), H = Math.floor(cssH * dpr);
    if (cv.width !== W || cv.height !== H) { cv.width = W; cv.height = H; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.clearRect(0, 0, cssW, cssH);

    const origin = { x: cssW * 0.42, y: cssH * 0.62 };

    // grid
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(cssW, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, cssH); ctx.stroke();
    ctx.restore();

    const maxSpd = Math.max(
      1,
      Math.hypot(V_bg.x, V_bg.y),
      Math.hypot(V_bw.x, V_bw.y),
      Math.hypot(V_cur.x, V_cur.y),
      Math.hypot(V_aw_to.x, V_aw_to.y)
    );
    const scale = (Math.min(cssW, cssH) * 0.34) / maxSpd;

    drawArrow(origin, V_bg,   scale, "COG", { width: 3, alpha: 1 });
    drawArrow(origin, V_bw,   scale, "BSP", { width: 2, alpha: 0.7, dash: [8, 6] });
    drawArrow(origin, V_cur,  scale, "cur", { width: 2, alpha: 0.55, dash: [2, 6] });

    // AW arrow points TO (wind velocity)
    const awOrigin = { x: origin.x, y: origin.y}; 
    drawArrow(awOrigin, V_aw_to, scale, "AW", { width: 1, alpha: 0.3 });

    drawBoat(origin, HDG);

    const box = { x: cssW - 240, y: 16, w: 224, h: 150 };
    drawInsetWind(box, V_gw_to, GWD_from, GWS);
  }

  // init
  setDefaults();
  readTheme();
  recalc(true);

  window.addEventListener("resize", () => recalc(false));
  const mq = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)");
  if (mq && mq.addEventListener) mq.addEventListener("change", () => recalc(false));
})();
</script>
</body>
</html>
