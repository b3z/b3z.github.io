<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sailing Processor Model (Single File)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 18px; font-weight: 650; }
    .grid { display: grid; grid-template-columns: 360px 1fr; gap: 16px; align-items: start; }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 96px; gap: 10px; align-items: center; margin: 10px 0; }
    label { font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 100%; }
    input[type="number"] { width: 100%; box-sizing: border-box; padding: 6px 8px; border-radius: 8px; border: 1px solid rgba(127,127,127,.35); background: transparent; }
    button { padding: 6px 8px; border-radius: 8px; border: 1px solid rgba(127,127,127,.35); background: transparent; }
    .small { font-size: 12px; opacity: .85; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    td { padding: 6px 8px; border-bottom: 1px solid rgba(127,127,127,.25); }
    td:first-child { opacity: .85; width: 42%; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; border:1px solid rgba(127,127,127,.35); font-size: 12px; }
    .toolbar { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-top: 8px; }
    canvas { width: 100%; height: 420px; border-radius: 12px; border: 1px solid rgba(127,127,127,.35); background: rgba(127,127,127,.06); display:block; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <h1>Sailing Processor Model (GWD/GWS + BSP + SET/DRIFT)</h1>

  <div class="grid">
    <div class="card">
      <div class="small">
        Inputs: <span class="mono">GWD, GWS, HDG, BSP, SET, DRIFT</span>.
        <br/>
        Model:
        <span class="mono">V_bg = V_bw + V_cur</span>,
        <span class="mono">V_aw = V_gw - V_bg</span>,
        <span class="mono">V_tw = V_gw - V_cur</span>.
        <br/>
        Wind dirs are <span class="mono">FROM</span>, boat/current dirs are <span class="mono">TO</span>.
      </div>

      <div class="toolbar">
        <span class="pill">deg</span>
        <span class="pill">kn</span>
      </div>

      <hr style="border:none;border-top:1px solid rgba(127,127,127,.25); margin: 12px 0;" />

      <div class="row">
        <label for="hdg">HDG</label>
        <input id="hdgN" type="number" step="1" />
      </div>
      <input id="hdg" type="range" min="0" max="359" step="1" />

      <div class="row">
        <label for="bsp">BSP</label>
        <input id="bspN" type="number" step="1" />
      </div>
      <input id="bsp" type="range" min="0" max="20" step="1" />

      <div class="row">
        <label for="gwd">GWD</label>
        <input id="gwdN" type="number" step="1" />
      </div>
      <input id="gwd" type="range" min="0" max="359" step="1" />

      <div class="row">
        <label for="gws">GWS</label>
        <input id="gwsN" type="number" step="1" />
      </div>
      <input id="gws" type="range" min="0" max="60" step="1" />

      <div class="row">
        <label for="set">SET</label>
        <input id="setN" type="number" step="1" />
      </div>
      <input id="set" type="range" min="0" max="359" step="1" />

      <div class="row">
        <label for="drift">DRIFT</label>
        <input id="driftN" type="number" step="1" />
      </div>
      <input id="drift" type="range" min="0" max="6" step="1" />

      <div class="toolbar">
        <button id="reset">Reset</button>
      </div>

      <div class="small" style="margin-top:10px;">
        AWA/TWA are signed in boat frame:
        <br/>• <span class="mono">+</span> starboard, <span class="mono">-</span> port
        <br/>• 0° = wind from straight ahead
      </div>
    </div>

    <div class="card">
      <table>
        <tbody>
          <tr><td>COG</td><td class="mono" id="cog"></td></tr>
          <tr><td>SOG</td><td class="mono" id="sog"></td></tr>

          <tr><td>AWA</td><td class="mono" id="awa"></td></tr>
          <tr><td>AWS</td><td class="mono" id="aws"></td></tr>

          <tr><td>TWA</td><td class="mono" id="twa"></td></tr>
          <tr><td>TWS</td><td class="mono" id="twsOut"></td></tr>
          <tr><td>TWD</td><td class="mono" id="twdOut"></td></tr>

          <tr><td>SET/DRIFT</td><td class="mono" id="setDrift"></td></tr>
          <tr><td>GWD/GWS</td><td class="mono" id="gwdGwsEcho"></td></tr>
        </tbody>
      </table>

      <div class="small" style="margin-top:10px;">
        Canvas vectors:
        <span class="mono">V_bw</span> (BSP),
        <span class="mono">V_cur</span>,
        <span class="mono">V_bg</span>,
        <span class="mono">V_gw</span> (from GWD/GWS),
        <span class="mono">V_aw</span>,
        <span class="mono">V_tw</span> (over water).
      </div>

      <div style="margin-top:10px;">
        <canvas id="cv" width="980" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const deg2rad = d => d * Math.PI / 180;
  const rad2deg = r => r * 180 / Math.PI;
  const wrap360 = d => (d % 360 + 360) % 360;

  // Bearing (deg true, TO) -> NE vector (x=E, y=N)
  function vecFromBearingTo(bearingDeg, speed) {
    const a = deg2rad(bearingDeg);
    return { x: speed * Math.sin(a), y: speed * Math.cos(a) };
  }

  // NE vector -> bearing (deg true, TO) + speed
  function bearingToFromVec(v) {
    const spd = Math.hypot(v.x, v.y);
    const brg = wrap360(rad2deg(Math.atan2(v.x, v.y)));
    return { bearing: brg, speed: spd };
  }

  // NE -> boat frame: x=forward, y=starboard (right)
  function vecNEToBoat(vNE, hdgDeg) {
    const a = deg2rad(hdgDeg);
    const forward =  vNE.x * Math.sin(a) + vNE.y * Math.cos(a);
    const starbd =  vNE.x * Math.cos(a) - vNE.y * Math.sin(a);
    return { x: forward, y: starbd };
  }

  // Wind dir FROM (meteo) -> NE vector TO (add 180)
  function windVecFromDirFrom(dirFromDeg, speed) {
    return vecFromBearingTo(wrap360(dirFromDeg + 180), speed);
  }

  // NE wind vector TO -> wind dir FROM
  function windDirFromVec(v) {
    const { bearing } = bearingToFromVec(v);
    return wrap360(bearing + 180);
  }

  // Boat-relative angle: 0=bows, +starboard, -port (using wind FROM vector in boat frame)
  function relAngleDegFromBoatVec(vBoat) {
    const ang = rad2deg(Math.atan2(vBoat.y, vBoat.x));
    return ((ang + 180) % 360) - 180;
  }

  const fmt = (x, digits=1) => Number.isFinite(x) ? x.toFixed(digits) : "—";
  const fmtDeg = (d) => Number.isFinite(d) ? `${wrap360(d).toFixed(0)}°` : "—";
  const fmtDegSigned = (d) => Number.isFinite(d) ? `${d.toFixed(0)}°` : "—";

  const el = id => document.getElementById(id);

  const inputs = {
    hdg: el("hdg"), hdgN: el("hdgN"),
    bsp: el("bsp"), bspN: el("bspN"),
    gwd: el("gwd"), gwdN: el("gwdN"),
    gws: el("gws"), gwsN: el("gwsN"),
    set: el("set"), setN: el("setN"),
    drift: el("drift"), driftN: el("driftN"),
    reset: el("reset")
  };

  const out = {
    cog: el("cog"), sog: el("sog"),
    awa: el("awa"), aws: el("aws"),
    twa: el("twa"), twsOut: el("twsOut"), twdOut: el("twdOut"),
    setDrift: el("setDrift"),
    gwdGwsEcho: el("gwdGwsEcho")
  };

  function bindRangeAndNumber(rangeEl, numEl) {
    function syncFromRange() { numEl.value = rangeEl.value; recalc(); }
    function syncFromNum() {
      const v = Number(numEl.value);
      if (Number.isFinite(v)) {
        rangeEl.value = String(Math.min(Number(rangeEl.max), Math.max(Number(rangeEl.min), v)));
      }
      recalc();
    }
    rangeEl.addEventListener("input", syncFromRange);
    numEl.addEventListener("input", syncFromNum);
  }

  bindRangeAndNumber(inputs.hdg, inputs.hdgN);
  bindRangeAndNumber(inputs.bsp, inputs.bspN);
  bindRangeAndNumber(inputs.gwd, inputs.gwdN);
  bindRangeAndNumber(inputs.gws, inputs.gwsN);
  bindRangeAndNumber(inputs.set, inputs.setN);
  bindRangeAndNumber(inputs.drift, inputs.driftN);

  inputs.reset.addEventListener("click", () => { setDefaults(); recalc(); });

  function setDefaults() {
    inputs.hdg.value = "318"; inputs.hdgN.value = "45";
    inputs.bsp.value = "8"; inputs.bspN.value = "8.0";
    inputs.gwd.value = "0"; inputs.gwdN.value = "0";
    inputs.gws.value = "14.0"; inputs.gwsN.value = "14.0";
    inputs.set.value = "135"; inputs.setN.value = "135";
    inputs.drift.value = "0"; inputs.driftN.value = "0.0";
  }

  function recalc() {
    const HDG = Number(inputs.hdg.value);
    const BSP = Number(inputs.bsp.value);

    const GWD_from = Number(inputs.gwd.value);
    const GWS = Number(inputs.gws.value);

    const SET_to = Number(inputs.set.value);
    const DRIFT = Number(inputs.drift.value);

    // boat through water (TO)
    const V_bw = vecFromBearingTo(HDG, BSP);

    // current (TO)
    const V_cur = vecFromBearingTo(SET_to, DRIFT);

    // ground velocity
    const V_bg = { x: V_bw.x + V_cur.x, y: V_bw.y + V_cur.y };
    const bg = bearingToFromVec(V_bg);
    const COG = bg.bearing;
    const SOG = bg.speed;

    // ground wind: given as FROM, stored as TO vector
    const V_gw = windVecFromDirFrom(GWD_from, GWS);

    // apparent wind at the boat (TO)
    const V_aw = { x: V_gw.x - V_bg.x, y: V_gw.y - V_bg.y };
    const V_aw_boat = vecNEToBoat(V_aw, HDG);

    // IMPORTANT: AWA is wind FROM relative to bow
    const V_aw_from_boat = { x: -V_aw_boat.x, y: -V_aw_boat.y };

    const AWS = Math.hypot(V_aw_boat.x, V_aw_boat.y);
    const AWA = relAngleDegFromBoatVec(V_aw_from_boat);

    // true wind over water (TO)
    const V_tw = { x: V_gw.x - V_cur.x, y: V_gw.y - V_cur.y };
    const TWS = Math.hypot(V_tw.x, V_tw.y);
    const TWD_from = windDirFromVec(V_tw);

    // TWA is wind FROM relative to bow
    const V_tw_boat = vecNEToBoat(V_tw, HDG);
    const V_tw_from_boat = { x: -V_tw_boat.x, y: -V_tw_boat.y };
    const TWA = relAngleDegFromBoatVec(V_tw_from_boat);

    // outputs
    out.cog.textContent = fmtDeg(COG);
    out.sog.textContent = `${fmt(SOG, 2)} kn`;

    out.awa.textContent = `${fmtDegSigned(AWA)} (${AWA >= 0 ? "stbd" : "port"})`;
    out.aws.textContent = `${fmt(AWS, 2)} kn`;

    out.twa.textContent = `${fmtDegSigned(TWA)} (${TWA >= 0 ? "stbd" : "port"})`;
    out.twsOut.textContent = `${fmt(TWS, 2)} kn`;
    out.twdOut.textContent = fmtDeg(TWD_from);

    out.setDrift.textContent = `${fmtDeg(SET_to)} / ${fmt(DRIFT, 2)} kn`;
    out.gwdGwsEcho.textContent = `${fmtDeg(GWD_from)} / ${fmt(GWS, 2)} kn`;

    drawCanvas({ HDG, V_bw, V_cur, V_bg, V_gw, V_aw, V_tw });
  }

  // ---------- canvas ----------
  const cv = el("cv");
  const ctx = cv.getContext("2d");

  function drawArrow(origin, vNE, scale, label) {
    const ox = origin.x, oy = origin.y;
    const x = ox + vNE.x * scale;
    const y = oy - vNE.y * scale;

    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(x, y);
    ctx.stroke();

    const ang = Math.atan2(y - oy, x - ox);
    const ah = 10;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - ah * Math.cos(ang - Math.PI/7), y - ah * Math.sin(ang - Math.PI/7));
    ctx.lineTo(x - ah * Math.cos(ang + Math.PI/7), y - ah * Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();

    ctx.fillText(label, x + 6, y + 4);
  }

  function drawCanvas(s) {
    const { HDG, V_bw, V_cur, V_bg, V_gw, V_aw, V_tw } = s;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = cv.clientWidth, cssH = cv.clientHeight;
    const W = Math.floor(cssW * dpr), H = Math.floor(cssH * dpr);
    if (cv.width !== W || cv.height !== H) { cv.width = W; cv.height = H; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.clearRect(0, 0, cssW, cssH);

    ctx.save();
    ctx.globalAlpha = 0.7;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(127,127,127,.55)";
    ctx.fillStyle = "rgba(127,127,127,.55)";

    const origin = { x: cssW * 0.5, y: cssH * 0.62 };

    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(cssW, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, cssH); ctx.stroke();

    ctx.fillText("E", cssW - 14, origin.y - 6);
    ctx.fillText("N", origin.x + 6, 14);
    ctx.restore();

    const maxSpd = Math.max(
      1,
      Math.hypot(V_bw.x, V_bw.y),
      Math.hypot(V_bg.x, V_bg.y),
      Math.hypot(V_cur.x, V_cur.y),
      Math.hypot(V_gw.x, V_gw.y),
      Math.hypot(V_aw.x, V_aw.y),
      Math.hypot(V_tw.x, V_tw.y)
    );
    const scale = (Math.min(cssW, cssH) * 0.28) / maxSpd;

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(30,30,30,.9)";
    ctx.fillStyle = "rgba(30,30,30,.9)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";

    // boat & current
    drawArrow(origin, V_bw, scale, "V_bw");
    drawArrow(origin, V_cur, scale, "V_cur");
    drawArrow(origin, V_bg, scale, "V_bg");

    // wind vectors from separate origin
    const wOrigin = { x: cssW * 0.5, y: cssH * 0.28 };
    drawArrow(wOrigin, V_gw, scale, "V_gw");
    drawArrow(wOrigin, V_aw, scale, "V_aw");
    drawArrow(wOrigin, V_tw, scale, "V_tw");

    // boat heading marker
    ctx.save();
    ctx.translate(origin.x, origin.y);
    ctx.rotate(deg2rad(HDG));
    ctx.strokeStyle = "rgba(127,127,127,.85)";
    ctx.fillStyle = "rgba(127,127,127,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -36);
    ctx.stroke();
    ctx.fillText("HDG", 6, -30);
    ctx.restore();
  }

  setDefaults();
  recalc();
  window.addEventListener("resize", recalc);
})();
</script>
</body>
</html>
