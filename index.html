<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sailing Processor Model (Single File)</title>
  <style>
    :root {
      color-scheme: light dark;

      --border: rgba(127,127,127,.35);
      --border2: rgba(127,127,127,.25);
      --bgCanvas: rgba(127,127,127,.06);

      --vec: rgba(30,30,30,.92);
      --grid: rgba(127,127,127,.45);
      --hdg: rgba(127,127,127,.85);

      --pos: #1a8f3a;
      --neg: #c62828;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --border: rgba(255,255,255,.18);
        --border2: rgba(255,255,255,.12);
        --bgCanvas: rgba(255,255,255,.06);

        --vec: rgba(245,245,245,.92);
        --grid: rgba(255,255,255,.22);
        --hdg: rgba(255,255,255,.60);

        --pos: #47d16a;
        --neg: #ff5a5a;
      }
    }

    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    h1 { margin: 0 0 12px 0; font-size: 18px; font-weight: 650; }
    .grid { display: grid; grid-template-columns: 420px 1fr; gap: 16px; align-items: start; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; align-items: center; margin: 10px 0; }
    label { font-size: 12px; opacity: 0.9; }
    input[type="range"] { width: 100%; }

    input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }

    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      font-size: 14px;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }

    .small { font-size: 12px; opacity: .85; line-height: 1.35; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 6px 8px; border-bottom: 1px solid var(--border2); }
    th { text-align: left; font-weight: 650; opacity: .9; }
    td:first-child { opacity: .85; width: 28%; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; border:1px solid var(--border); font-size: 12px; }
    .toolbar { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; margin-top: 8px; }
    canvas { width: 100%; height: 420px; border-radius: 12px; border: 1px solid var(--border); background: var(--bgCanvas); display:block; }

    .numCtl { display: grid; grid-template-columns: 52px 1fr 52px; gap: 8px; align-items: center; }
    .pmBtn { padding: 10px 0; font-weight: 700; font-size: 18px; line-height: 1; }

    .delta { opacity: .9; }
    .delta.mono, .base.mono { font-variant-numeric: tabular-nums; }
    .delta.pos { color: var(--pos); }
    .delta.neg { color: var(--neg); }
    .delta.zero, .base.zero { opacity: .55; }
  </style>
</head>
<body>
  <h1>Sailing Processor Model (GWD/GWS + BSP + SET/DRIFT)</h1>

  <div class="grid">
    <div class="card">
      <div class="small">
        Inputs: <span class="mono">GWD, GWS, HDG, BSP, SET, DRIFT</span>.
        <br/>
        Model:
        <span class="mono">V_bg = V_bw + V_cur</span>,
        <span class="mono">V_aw = V_gw - V_bg</span>,
        <span class="mono">V_tw = V_gw - V_cur</span>.
        <br/>
        Wind dirs are <span class="mono">FROM</span>, boat/current dirs are <span class="mono">TO</span>.
      </div>

      <div class="toolbar">
        <span class="pill">deg</span>
        <span class="pill">kn</span>
      </div>

      <hr style="border:none;border-top:1px solid var(--border2); margin: 12px 0;" />

      <!-- HDG -->
      <div class="row">
        <label for="hdg">HDG</label>
        <div class="numCtl">
          <button class="pmBtn" id="hdgM" aria-label="HDG minus">−</button>
          <input id="hdgN" type="number" step="1" />
          <button class="pmBtn" id="hdgP" aria-label="HDG plus">+</button>
        </div>
      </div>
      <input id="hdg" type="range" min="0" max="359" step="1" />

      <!-- BSP -->
      <div class="row">
        <label for="bsp">BSP</label>
        <div class="numCtl">
          <button class="pmBtn" id="bspM" aria-label="BSP minus">−</button>
          <input id="bspN" type="number" step="1" />
          <button class="pmBtn" id="bspP" aria-label="BSP plus">+</button>
        </div>
      </div>
      <input id="bsp" type="range" min="0" max="20" step="1" />

      <!-- GWD -->
      <div class="row">
        <label for="gwd">GWD</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwdM" aria-label="GWD minus">−</button>
          <input id="gwdN" type="number" step="1" />
          <button class="pmBtn" id="gwdP" aria-label="GWD plus">+</button>
        </div>
      </div>
      <input id="gwd" type="range" min="0" max="359" step="1" />

      <!-- GWS -->
      <div class="row">
        <label for="gws">GWS</label>
        <div class="numCtl">
          <button class="pmBtn" id="gwsM" aria-label="GWS minus">−</button>
          <input id="gwsN" type="number" step="1" />
          <button class="pmBtn" id="gwsP" aria-label="GWS plus">+</button>
        </div>
      </div>
      <input id="gws" type="range" min="0" max="60" step="1" />

      <!-- SET -->
      <div class="row">
        <label for="set">SET</label>
        <div class="numCtl">
          <button class="pmBtn" id="setM" aria-label="SET minus">−</button>
          <input id="setN" type="number" step="1" />
          <button class="pmBtn" id="setP" aria-label="SET plus">+</button>
        </div>
      </div>
      <input id="set" type="range" min="0" max="359" step="1" />

      <!-- DRIFT -->
      <div class="row">
        <label for="drift">DRIFT</label>
        <div class="numCtl">
          <button class="pmBtn" id="driftM" aria-label="DRIFT minus">−</button>
          <input id="driftN" type="number" step="1" />
          <button class="pmBtn" id="driftP" aria-label="DRIFT plus">+</button>
        </div>
      </div>
      <input id="drift" type="range" min="0" max="6" step="1" />

      <div class="toolbar">
        <button id="baseline">Set baseline</button>
        <button id="reset">Reset</button>
        <span class="small" id="baselineInfo" style="margin-left:auto;"></span>
      </div>

      <div class="small" style="margin-top:10px;">
        AWA/TWA are signed in boat frame:
        <br/>• <span class="mono">+</span> starboard, <span class="mono">-</span> port
        <br/>• 0° = wind from straight ahead
      </div>
    </div>

    <div class="card">
      <table>
        <thead>
          <tr>
            <th>Key</th>
            <th class="mono">Baseline</th>
            <th class="mono">Value</th>
            <th class="mono">Δ</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>COG</td><td class="mono base" id="cogB"></td><td class="mono" id="cog"></td><td class="mono delta" id="cogD"></td></tr>
          <tr><td>SOG</td><td class="mono base" id="sogB"></td><td class="mono" id="sog"></td><td class="mono delta" id="sogD"></td></tr>

          <tr><td>AWA</td><td class="mono base" id="awaB"></td><td class="mono" id="awa"></td><td class="mono delta" id="awaD"></td></tr>
          <tr><td>AWS</td><td class="mono base" id="awsB"></td><td class="mono" id="aws"></td><td class="mono delta" id="awsD"></td></tr>

          <tr><td>TWA</td><td class="mono base" id="twaB"></td><td class="mono" id="twa"></td><td class="mono delta" id="twaD"></td></tr>
          <tr><td>TWS</td><td class="mono base" id="twsB"></td><td class="mono" id="twsOut"></td><td class="mono delta" id="twsD"></td></tr>
          <tr><td>TWD</td><td class="mono base" id="twdB"></td><td class="mono" id="twdOut"></td><td class="mono delta" id="twdD"></td></tr>

          <tr><td>SET/DRIFT</td><td class="mono base" id="setDriftB"></td><td class="mono" id="setDrift"></td><td class="mono delta" id="setDriftD"></td></tr>
          <tr><td>GWD/GWS</td><td class="mono base" id="gwdGwsB"></td><td class="mono" id="gwdGwsEcho"></td><td class="mono delta" id="gwdGwsD"></td></tr>
        </tbody>
      </table>

      <!-- <div class="small" style="margin-top:10px;"> -->
      <!--   Canvas: boat + <span class="mono">V_bg</span> (thick), <span class="mono">V_bw</span> (dashed), <span class="mono">V_cur</span> (thin), <span class="mono">V_aw(FROM)</span>. -->
      <!--   Inset: <span class="mono">V_gw(FROM)</span>. -->
      <!-- </div> -->

      <div style="margin-top:10px;">
        <canvas id="cv" width="980" height="520"></canvas>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- helpers ----------
  const deg2rad = d => d * Math.PI / 180;
  const rad2deg = r => r * 180 / Math.PI;
  const wrap360 = d => (d % 360 + 360) % 360;

  function angDiffDeg(a, b) {
    let d = ((a - b + 540) % 360) - 180;
    if (d === -180) d = 180;
    return d;
  }

  function vecFromBearingTo(bearingDeg, speed) {
    const a = deg2rad(bearingDeg);
    return { x: speed * Math.sin(a), y: speed * Math.cos(a) };
  }

  function bearingToFromVec(v) {
    const spd = Math.hypot(v.x, v.y);
    const brg = wrap360(rad2deg(Math.atan2(v.x, v.y)));
    return { bearing: brg, speed: spd };
  }

  function vecNEToBoat(vNE, hdgDeg) {
    const a = deg2rad(hdgDeg);
    const forward =  vNE.x * Math.sin(a) + vNE.y * Math.cos(a);
    const starbd =  vNE.x * Math.cos(a) - vNE.y * Math.sin(a);
    return { x: forward, y: starbd };
  }

  function windVecFromDirFrom(dirFromDeg, speed) {
    return vecFromBearingTo(wrap360(dirFromDeg + 180), speed);
  }

  function windDirFromVec(v) {
    const { bearing } = bearingToFromVec(v);
    return wrap360(bearing + 180);
  }

  function relAngleDegFromBoatVec(vBoat) {
    const ang = rad2deg(Math.atan2(vBoat.y, vBoat.x));
    return ((ang + 180) % 360) - 180;
  }

  const fmt = (x, digits=1) => Number.isFinite(x) ? x.toFixed(digits) : "—";
  const fmtDeg = (d) => Number.isFinite(d) ? `${wrap360(d).toFixed(0)}°` : "—";
  const fmtDegSigned = (d) => Number.isFinite(d) ? `${d.toFixed(0)}°` : "—";

  const el = id => document.getElementById(id);

  const inputs = {
    hdg: el("hdg"), hdgN: el("hdgN"), hdgM: el("hdgM"), hdgP: el("hdgP"),
    bsp: el("bsp"), bspN: el("bspN"), bspM: el("bspM"), bspP: el("bspP"),
    gwd: el("gwd"), gwdN: el("gwdN"), gwdM: el("gwdM"), gwdP: el("gwdP"),
    gws: el("gws"), gwsN: el("gwsN"), gwsM: el("gwsM"), gwsP: el("gwsP"),
    set: el("set"), setN: el("setN"), setM: el("setM"), setP: el("setP"),
    drift: el("drift"), driftN: el("driftN"), driftM: el("driftM"), driftP: el("driftP"),
    baseline: el("baseline"),
    baselineInfo: el("baselineInfo"),
    reset: el("reset")
  };

  const out = {
    cog: el("cog"), sog: el("sog"),
    awa: el("awa"), aws: el("aws"),
    twa: el("twa"), twsOut: el("twsOut"), twdOut: el("twdOut"),
    setDrift: el("setDrift"),
    gwdGwsEcho: el("gwdGwsEcho"),

    cogD: el("cogD"), sogD: el("sogD"),
    awaD: el("awaD"), awsD: el("awsD"),
    twaD: el("twaD"), twsD: el("twsD"), twdD: el("twdD"),
    setDriftD: el("setDriftD"),
    gwdGwsD: el("gwdGwsD"),

    // baseline column
    cogB: el("cogB"), sogB: el("sogB"),
    awaB: el("awaB"), awsB: el("awsB"),
    twaB: el("twaB"), twsB: el("twsB"), twdB: el("twdB"),
    setDriftB: el("setDriftB"),
    gwdGwsB: el("gwdGwsB"),
  };

  const state = {
    baseline: null,
    lastComputed: null,
    theme: null
  };

  function readTheme() {
    const cs = getComputedStyle(document.documentElement);
    state.theme = {
      vec: cs.getPropertyValue("--vec").trim() || "rgba(30,30,30,.92)",
      grid: cs.getPropertyValue("--grid").trim() || "rgba(127,127,127,.45)",
      hdg: cs.getPropertyValue("--hdg").trim() || "rgba(127,127,127,.85)",
    };
  }

  function bindRangeAndNumber(rangeEl, numEl) {
    function clampToRange(v) {
      const min = Number(rangeEl.min), max = Number(rangeEl.max);
      if (!Number.isFinite(v)) return Number(rangeEl.value);
      return Math.min(max, Math.max(min, v));
    }
    function syncFromRange() { numEl.value = rangeEl.value; recalc(); }
    function syncFromNum() {
      const v = clampToRange(Number(numEl.value));
      rangeEl.value = String(v);
      numEl.value = String(v);
      recalc();
    }
    rangeEl.addEventListener("input", syncFromRange);
    numEl.addEventListener("input", syncFromNum);
  }

  bindRangeAndNumber(inputs.hdg, inputs.hdgN);
  bindRangeAndNumber(inputs.bsp, inputs.bspN);
  bindRangeAndNumber(inputs.gwd, inputs.gwdN);
  bindRangeAndNumber(inputs.gws, inputs.gwsN);
  bindRangeAndNumber(inputs.set, inputs.setN);
  bindRangeAndNumber(inputs.drift, inputs.driftN);

  function nudge(key, dir) {
    const rangeEl = inputs[key];
    const numEl = inputs[key + "N"];
    const step = Number(rangeEl.step || 1);
    const cur = Number(rangeEl.value);
    let next = cur + dir * step;

    if (key === "hdg" || key === "gwd" || key === "set") next = wrap360(next);

    const min = Number(rangeEl.min), max = Number(rangeEl.max);
    if (!(key === "hdg" || key === "gwd" || key === "set")) next = Math.min(max, Math.max(min, next));

    rangeEl.value = String(next);
    numEl.value = String(next);
    recalc();
  }

  inputs.hdgM.addEventListener("click", () => nudge("hdg", -1));
  inputs.hdgP.addEventListener("click", () => nudge("hdg", +1));
  inputs.bspM.addEventListener("click", () => nudge("bsp", -1));
  inputs.bspP.addEventListener("click", () => nudge("bsp", +1));
  inputs.gwdM.addEventListener("click", () => nudge("gwd", -1));
  inputs.gwdP.addEventListener("click", () => nudge("gwd", +1));
  inputs.gwsM.addEventListener("click", () => nudge("gws", -1));
  inputs.gwsP.addEventListener("click", () => nudge("gws", +1));
  inputs.setM.addEventListener("click", () => nudge("set", -1));
  inputs.setP.addEventListener("click", () => nudge("set", +1));
  inputs.driftM.addEventListener("click", () => nudge("drift", -1));
  inputs.driftP.addEventListener("click", () => nudge("drift", +1));

  function setDefaults() {
    inputs.hdg.value = "318"; inputs.hdgN.value = "318";
    inputs.bsp.value = "8"; inputs.bspN.value = "8";
    inputs.gwd.value = "0"; inputs.gwdN.value = "0";
    inputs.gws.value = "14"; inputs.gwsN.value = "14";
    inputs.set.value = "135"; inputs.setN.value = "135";
    inputs.drift.value = "0"; inputs.driftN.value = "0";
  }

  function setDeltaCell(cell, delta, isAngle=false, digits=2) {
    cell.classList.remove("pos", "neg", "zero");
    if (!Number.isFinite(delta)) { cell.textContent = "—"; cell.classList.add("zero"); return; }
    const eps = isAngle ? 0.5 : 1e-9;
    if (Math.abs(delta) < eps) { cell.textContent = "0"; cell.classList.add("zero"); return; }
    const sign = delta > 0 ? "+" : "";
    const txt = isAngle ? `${sign}${delta.toFixed(0)}°` : `${sign}${delta.toFixed(digits)}`;
    cell.textContent = txt;
    cell.classList.add(delta > 0 ? "pos" : "neg");
  }

  function setBaseCell(cell, txt) {
    cell.classList.remove("zero");
    cell.textContent = txt;
    if (txt === "—") cell.classList.add("zero");
  }

  function clearDeltasAndBaselineCols() {
    // baseline col
    for (const k of ["cogB","sogB","awaB","awsB","twaB","twsB","twdB","setDriftB","gwdGwsB"]) setBaseCell(out[k], "—");
    // delta col
    for (const k of ["cogD","sogD","awaD","awsD","twaD","twsD","twdD","setDriftD","gwdGwsD"]) {
      out[k].textContent = "—";
      out[k].className = "mono delta zero";
    }
  }

  function setBaselineSnapshot(snap) {
    state.baseline = { ...snap };
    const t = new Date();
    inputs.baselineInfo.textContent =
      `baseline @ ${t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'})}`;
  }

  inputs.baseline.addEventListener("click", () => {
    recalc(false); // refresh lastComputed
    if (state.lastComputed) setBaselineSnapshot(state.lastComputed);
    recalc(false); // redraw with baseline column + deltas
  });

  inputs.reset.addEventListener("click", () => {
    setDefaults();
    state.baseline = null;
    state.lastComputed = null;
    inputs.baselineInfo.textContent = "";
    recalc(true);
  });

  function recalc(resetDelta=false) {
    readTheme();

    const HDG = Number(inputs.hdg.value);
    const BSP = Number(inputs.bsp.value);

    const GWD_from = Number(inputs.gwd.value);
    const GWS = Number(inputs.gws.value);

    const SET_to = Number(inputs.set.value);
    const DRIFT = Number(inputs.drift.value);

    // boat through water (TO)
    const V_bw = vecFromBearingTo(HDG, BSP);

    // current (TO)
    const V_cur = vecFromBearingTo(SET_to, DRIFT);

    // ground velocity
    const V_bg = { x: V_bw.x + V_cur.x, y: V_bw.y + V_cur.y };
    const bg = bearingToFromVec(V_bg);
    const COG = bg.bearing;
    const SOG = bg.speed;

    // ground wind: given as FROM, stored as TO vector
    const V_gw_to = windVecFromDirFrom(GWD_from, GWS);
    const V_gw_from = { x: -V_gw_to.x, y: -V_gw_to.y };

    // apparent wind at the boat (TO)
    const V_aw_to = { x: V_gw_to.x - V_bg.x, y: V_gw_to.y - V_bg.y };
    const V_aw_from = { x: -V_aw_to.x, y: -V_aw_to.y };
    const V_aw_boat_to = vecNEToBoat(V_aw_to, HDG);
    const V_aw_from_boat = { x: -V_aw_boat_to.x, y: -V_aw_boat_to.y };

    const AWS = Math.hypot(V_aw_boat_to.x, V_aw_boat_to.y);
    const AWA = relAngleDegFromBoatVec(V_aw_from_boat);

    // true wind over water (TO)
    const V_tw_to = { x: V_gw_to.x - V_cur.x, y: V_gw_to.y - V_cur.y };
    const TWS = Math.hypot(V_tw_to.x, V_tw_to.y);
    const TWD_from = windDirFromVec(V_tw_to);

    const V_tw_boat = vecNEToBoat(V_tw_to, HDG);
    const V_tw_from_boat = { x: -V_tw_boat.x, y: -V_tw_boat.y };
    const TWA = relAngleDegFromBoatVec(V_tw_from_boat);

    // outputs (value)
    out.cog.textContent = fmtDeg(COG);
    out.sog.textContent = `${fmt(SOG, 2)} kn`;

    out.awa.textContent = `${fmtDegSigned(AWA)} (${AWA >= 0 ? "stbd" : "port"})`;
    out.aws.textContent = `${fmt(AWS, 2)} kn`;

    out.twa.textContent = `${fmtDegSigned(TWA)} (${TWA >= 0 ? "stbd" : "port"})`;
    out.twsOut.textContent = `${fmt(TWS, 2)} kn`;
    out.twdOut.textContent = fmtDeg(TWD_from);

    out.setDrift.textContent = `${fmtDeg(SET_to)} / ${fmt(DRIFT, 2)} kn`;
    out.gwdGwsEcho.textContent = `${fmtDeg(GWD_from)} / ${fmt(GWS, 2)} kn`;

    const snap = { COG, SOG, AWA, AWS, TWA, TWS, TWD_from, SET_to, DRIFT, GWD_from, GWS };
    state.lastComputed = snap;

    if (resetDelta) {
      clearDeltasAndBaselineCols();
    } else if (!state.baseline) {
      // baseline not set => show — in baseline & delta cols
      clearDeltasAndBaselineCols();
    } else {
      const b = state.baseline;

      // baseline column
      setBaseCell(out.cogB, `${fmtDeg(b.COG)}`);
      setBaseCell(out.sogB, `${fmt(b.SOG,2)} kn`);
      setBaseCell(out.awaB, `${fmtDegSigned(b.AWA)}`);
      setBaseCell(out.awsB, `${fmt(b.AWS,2)} kn`);
      setBaseCell(out.twaB, `${fmtDegSigned(b.TWA)}`);
      setBaseCell(out.twsB, `${fmt(b.TWS,2)} kn`);
      setBaseCell(out.twdB, `${fmtDeg(b.TWD_from)}`);
      setBaseCell(out.setDriftB, `${fmtDeg(b.SET_to)} / ${fmt(b.DRIFT,2)} kn`);
      setBaseCell(out.gwdGwsB, `${fmtDeg(b.GWD_from)} / ${fmt(b.GWS,2)} kn`);

      // deltas vs baseline
      setDeltaCell(out.cogD, angDiffDeg(COG, b.COG), true);
      setDeltaCell(out.sogD, SOG - b.SOG, false, 2);

      setDeltaCell(out.awaD, AWA - b.AWA, true);
      setDeltaCell(out.awsD, AWS - b.AWS, false, 2);

      setDeltaCell(out.twaD, TWA - b.TWA, true);
      setDeltaCell(out.twsD, TWS - b.TWS, false, 2);
      setDeltaCell(out.twdD, angDiffDeg(TWD_from, b.TWD_from), true);

      // SET/DRIFT combined
      const dSet = angDiffDeg(SET_to, b.SET_to);
      const dDrift = DRIFT - b.DRIFT;
      out.setDriftD.classList.remove("pos","neg","zero");
      const s1 = (Math.abs(dSet) < 0.5) ? "0°" : `${dSet > 0 ? "+" : ""}${dSet.toFixed(0)}°`;
      const s2 = (Math.abs(dDrift) < 1e-9) ? "0" : `${dDrift > 0 ? "+" : ""}${dDrift.toFixed(2)}`;
      out.setDriftD.textContent = `${s1} / ${s2}`;
      if (Math.abs(dDrift) < 1e-9) out.setDriftD.classList.add("zero");
      else out.setDriftD.classList.add(dDrift > 0 ? "pos" : "neg");

      // GWD/GWS combined
      const dGwd = angDiffDeg(GWD_from, b.GWD_from);
      const dGws = GWS - b.GWS;
      out.gwdGwsD.classList.remove("pos","neg","zero");
      const g1 = (Math.abs(dGwd) < 0.5) ? "0°" : `${dGwd > 0 ? "+" : ""}${dGwd.toFixed(0)}°`;
      const g2 = (Math.abs(dGws) < 1e-9) ? "0" : `${dGws > 0 ? "+" : ""}${dGws.toFixed(2)}`;
      out.gwdGwsD.textContent = `${g1} / ${g2}`;
      if (Math.abs(dGws) < 1e-9) out.gwdGwsD.classList.add("zero");
      else out.gwdGwsD.classList.add(dGws > 0 ? "pos" : "neg");
    }

    drawCanvas({
      HDG,
      V_bw,
      V_cur,
      V_bg,
      V_aw_from,
      V_gw_from,
      GWD_from,
      GWS
    });
  }

  // ---------- canvas ----------
  const cv = el("cv");
  const ctx = cv.getContext("2d");

  function drawArrow(origin, vNE, scale, label, style={}) {
    const ox = origin.x, oy = origin.y;
    const x = ox + vNE.x * scale;
    const y = oy - vNE.y * scale;

    ctx.save();
    ctx.strokeStyle = style.stroke || state.theme.vec;
    ctx.fillStyle = style.fill || state.theme.vec;
    ctx.lineWidth = style.width ?? 2;
    ctx.globalAlpha = style.alpha ?? 1;
    if (style.dash) ctx.setLineDash(style.dash);

    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(x, y);
    ctx.stroke();

    const ang = Math.atan2(y - oy, x - ox);
    const ah = style.head ?? 10;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - ah * Math.cos(ang - Math.PI/7), y - ah * Math.sin(ang - Math.PI/7));
    ctx.lineTo(x - ah * Math.cos(ang + Math.PI/7), y - ah * Math.sin(ang + Math.PI/7));
    ctx.closePath();
    ctx.fill();

    if (label) {
      ctx.setLineDash([]);
      ctx.globalAlpha = 1;
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
      ctx.fillText(label, x + 6, y + 4);
    }
    ctx.restore();
  }

  function drawBoat(origin, hdgDeg) {
    ctx.save();
    ctx.translate(origin.x, origin.y);
    ctx.rotate(deg2rad(hdgDeg));
    ctx.strokeStyle = state.theme.vec;
    ctx.fillStyle = state.theme.vec;

    // simple hull (triangle-ish)
    const L = 26, W = 14;
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -L);
    ctx.lineTo(W, L * 0.65);
    ctx.lineTo(0, L * 0.35);
    ctx.lineTo(-W, L * 0.65);
    ctx.closePath();
    ctx.stroke();

    // centerline / bow mark
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -L - 8);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = state.theme.hdg;
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText("HDG", 10, -L - 6);

    ctx.restore();
  }

  function drawInsetWind(box, V_gw_from, GWD_from, GWS) {
    ctx.save();

    // box
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = state.theme.grid;
    ctx.fillStyle = "transparent";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(box.x, box.y, box.w, box.h, 10);
    ctx.stroke();

    // title
    ctx.globalAlpha = 1;
    ctx.fillStyle = state.theme.vec;
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace";
    ctx.fillText(`GWD/GWS ${wrap360(GWD_from).toFixed(0)}° / ${Number(GWS).toFixed(1)} kn`, box.x + 10, box.y + 18);

    // tiny compass cross
    const cx = box.x + box.w * 0.5;
    const cy = box.y + box.h * 0.62;
    ctx.globalAlpha = 0.6;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(box.x + 10, cy); ctx.lineTo(box.x + box.w - 10, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, box.y + 30); ctx.lineTo(cx, box.y + box.h - 10); ctx.stroke();

    // arrow scaled to box
    const maxSpd = Math.max(1, Math.hypot(V_gw_from.x, V_gw_from.y));
    const scale = (Math.min(box.w, box.h) * 0.28) / maxSpd;
    drawArrow({ x: cx, y: cy }, V_gw_from, scale, "GW", { width: 2, alpha: 1 });

    ctx.restore();
  }

  function drawCanvas(s) {
    const { HDG, V_bw, V_cur, V_bg, V_aw_from, V_gw_from, GWD_from, GWS } = s;

    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = cv.clientWidth, cssH = cv.clientHeight;
    const W = Math.floor(cssW * dpr), H = Math.floor(cssH * dpr);
    if (cv.width !== W || cv.height !== H) { cv.width = W; cv.height = H; }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.clearRect(0, 0, cssW, cssH);

    // main origin (boat)
    const origin = { x: cssW * 0.42, y: cssH * 0.62 };

    // light grid (less dominant)
    ctx.save();
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1;
    ctx.strokeStyle = state.theme.grid;
    ctx.beginPath(); ctx.moveTo(0, origin.y); ctx.lineTo(cssW, origin.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, cssH); ctx.stroke();
    ctx.restore();

    // scaling based on the few vectors we draw
    const maxSpd = Math.max(
      1,
      Math.hypot(V_bg.x, V_bg.y),
      Math.hypot(V_bw.x, V_bw.y),
      Math.hypot(V_cur.x, V_cur.y),
      Math.hypot(V_aw_from.x, V_aw_from.y)
    );
    const scale = (Math.min(cssW, cssH) * 0.34) / maxSpd;

    // vectors (monochrome, different line styles to reduce clutter)
    drawArrow(origin, V_bg, scale, "COG", { width: 3, alpha: 1 });
    drawArrow(origin, V_bw, scale, "BSP", { width: 2, alpha: 0.7, dash: [8, 6] });
    drawArrow(origin, V_cur, scale, "cur", { width: 2, alpha: 0.55, dash: [2, 6] });
    drawArrow(origin, V_aw_from, scale, "AW", { width: 1, alpha: 0.3 });

    // boat
    drawBoat(origin, HDG);

    // inset top-right: ground wind
    const box = { x: cssW - 240, y: 16, w: 224, h: 150 };
    drawInsetWind(box, V_gw_from, GWD_from, GWS);
  }

  // init
  setDefaults();
  readTheme();
  recalc(true);

  // resize + theme changes
  window.addEventListener("resize", () => recalc(false));
  const mq = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)");
  if (mq && mq.addEventListener) mq.addEventListener("change", () => recalc(false));
})();
</script>
</body>
</html>
